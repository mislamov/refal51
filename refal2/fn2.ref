Go {
	= 
	<File "include/res.h"
        '#include "direfal.h" \n'
        '#include "system.h" \n'	
	>
	<File "src/res.cc"
        '#include "direfal.h" \n'
        '#include "commands.h" \n'
        '#include "system.h" \n'
        '#include "res.h" \n'
        <TreeToCode <TokensToTree <DelComments <RefalTokens <Mount 'fn.ref'>>>>>>;
}

AppendFunction {
	e.line = <File "include/res.h" <Mount "include/res.h"> '\n' e.line>;
}

TreeToCode {
	("FUNCTION" e.funk) e.next =
				<TreeToCode_function e.funk>
				<TreeToCode e.next>;
	("TEMPLATE" e.templ) e.next =
				<TreeToCode_template e.templ>
				<TreeToCode e.next>;

	=;
}

DefFunction {
	t.name = 'DataChain* ' t.name '(DataCursor arg_from, DataCursor arg_to, ExecContext *context)' ;
}

TreeToCode_function {
	t.name e.e =
			<AppendFunction  <DefFunction t.name> ';'>
			'\n' <DefFunction t.name> '{'  '\n'
  			'DataChain *result = new DataChain(); \n'
  			'DataChain *tmp_chain = new DataChain(); \n'
			<TreeToCode_sentences 1 e.e>
			'\n' '}' '\n';

}
TreeToCode_template {
	t.name ("LEFT-PART" e.leftpart),
				<Build (e.leftpart)('arg_from')('arg_to')('fail')> : (e.code)(e.rollback_label) =
					'\n' 'struct ' t.name '{' '\n'
						<TreeToCode_template_struct <DelDoubles <GetVars e.leftpart>>>
					'\n' '}' '\n'

					'\n' 'bool parse_' t.name '(DataCursor arg_from, DataCursor arg_to, RefMap *map){' '\n'
						'// подготовка к сопоставлению шаблона' '\n'
						'if (map!=0){ goto ' e.rollback_label '; }' '\n'
						'map = new RefMap(); //malloc(sizeof(RefMap));' '\n'
						e.code
						'fail: ' '\n'
						'// обработка неуспеха \n'
						'printf("fail!!!");' '\n'
						'return false;' '\n\n'
					'\n' '}' '\n';
}

GetVars {
	&VAR.v e.e = @.v::name <GetVars e.e>;
	(e.1) e.e  = <GetVars e.1> <GetVars e.e>;
	t.1 e.e = <GetVars e.e>;
	=;
}

DelDoubles {
	(t. t.1) e.A (t.x t.1) e.B  =  <DelDoubles e.A (t.x t.1) e.B>;
	theword.v  e.e = (@.v::value) <DelDoubles e.e>;
	theint.v  e.e  = (@.v::value) <DelDoubles e.e>;
	=;
}

TreeToCode_sentences {
	t.order ("SENTENCE" ("LEFT-PART" e.leftpart)("RIGHT-PART" e.result)) e.e,
				<Build (e.leftpart)('arg_from')('arg_to')('sentence_after_' t.order)> : (e.code)(e.rollback_label) =
						<AppendFunction '// ' <META2TEXT e.leftpart> '  =  ' <META2TEXT e.result>>
						'\n{'
						'\n'
						'// подготовка предложения \n'
						e.code
						'\n'
						'// подготовка подстановки \n'
						<SubstCompile ('result') e.result> '\n'
						'return result; \n'
						'}\n'
						'sentence_after_' t.order ': ' '\n'
						<TreeToCode_sentences <Add 1 t.order> e.e>;

	0 = <Prout 'ERROR! EMPTY SENTENCE LIST'><Exit>;
	t.else = 			'\n'  '// подготовка к возвращению неуспеха' '\n' 'std::cout << "fail!";' '\n' 'return 0;' '\n';
}


TreeToCode_template_struct {
	(e.v) e.e	=
					'DataCursor var_' e.v '_l; ' '\n'
					'DataCursor var_' e.v '_r; ' '\n'
					<TreeToCode_template_struct e.e>;
	=;
}

/**
* код передвижения переменной по цепочке, ограниченной значением e.border
*/
INC {	(e.var)(e.border)(e.rollback_label) = '/*INC*/	if (!INC(' e.var ', ' e.border ')) goto ' e.rollback_label ';' '\n'}

/**
* код проверки завершения сопоставления
*/
ISEMPTY {	(e.l)(e.r)(e.rollback_label) = '/*ISEMPTY*/	if ('e.l'!=0 && ' e.r ' != ' e.l ') goto ' e.rollback_label ';' '\n'}


EQ {
    (e.v1)(e.v2)(e.roll)  =   'if (' e.v1 '!=' e.v2 ') goto ' e.roll;
}

CHAIN_FIRST {
	e.chain_var = e.chain_var'->at_before_first()';
}

CHAIN_LAST {
	e.chain_var = e.chain_var'->at_last()';
}

/*
* код проверки совпадения символаов по типу и значению
*/
EQSYM {
	("text" e.val)(e.var)(e.border)(e.rollback_label),
		<Compare <Lenw e.val> 1> : '+',
		<RandomIdName> : e.alphas,
		<RandomIdName> : e.texttmp
	=
		'\t' 'static DataChain *' e.texttmp ' = text_to_chain("' e.val '");' '\n'
		'\t' 'static DataCursor ' e.texttmp '_l = ' <CHAIN_FIRST e.texttmp> ';' '\n'
		'\t' 'static DataCursor ' e.texttmp '_r = ' <CHAIN_LAST e.texttmp> ';' '\n'
		<SLIDE (e.var)(e.border)(e.texttmp '_l')(e.texttmp '_r')(e.rollback_label)>;

	("text" s.value)(e.var)(e.border)(e.rollback_label),
		<RandomIdName> : e.alphas
	=
                '\t' 'if (' e.var '.container->type != text || *(' e.var '.container->value.text + 'e.var'.index) != \'' @.value '\') goto ' e.rollback_label ';\n';

	("int" e.value)(e.var)(e.border)(e.rollback_label)
	=
                '\t' 'if ('e.var '.container->type != integer || 'e.var '.container->value.num != ' e.value ') goto ' e.rollback_label ';\n';

	("word" e.value)(e.var)(e.border)(e.rollback_label)
	=
                '\t' 'if ('e.var '.container->type != word || !memcmp('e.var '.container->value.word.value, "' e.value '", 'e.var '.container->value.word.leng)) goto ' e.rollback_label ';\n';

/*
	(t.type e.val)(e.var)(e.border)(e.rollback_label)
			=	'\t' 'if (('<TYPEP t.type e.var> ') || !(**' e.var ' == ' e.val ')) goto ' e.rollback_label ';\n';
*/
}


/*
* код проверки аргумента на то, является ли он структурной скобкой.
* Если да, то e.newfrom и e.newto - это смотрящие внутрь скобки переменные-границы'
*/
JMP_BRACKET {
	( e.br )(e.newfrom)(e.newto) =
			'//// JMP_BRACKET \n'
			'\t' e.newfrom' = 'e.br'.container->value.bracket_data.chain->at_before_first();' '\n'
			'\t' e.newto'   = 'e.br'.container->value.bracket_data.chain->at_last();' '\n'
}

ISBRACKET {
    (e.var)(e.rollback_label) =
	    '//// ISBRACKET \n'
	    '\t' 'if (' e.var '.container->type != struct_bracket) goto ' e.rollback_label ';' '\n';
}


/* простое присваивание */
SET {
    (e.var)(e.value) = '/*SET*/\t' e.var ' = ' e.value ';' '\n';
}

JMP {
    e.label = '/*JMP*/\t' 'goto ' e.label ';' '\n';
}

SYMBOLP {
    (e.var)(e.rollback) = '\t' 'if (! isSymbolType(' e.var '.container->type)) goto ' e.rollback ';\n';
}


DEF {
    e.var =
        '/*DEF*/\t' 'DataCursor ' e.var ';\n'
}

LABEL {
	e.lab = e.lab ': \n';
}
/* сравнение известной подцепочки с текущей */
SLIDE {
	(e.curr)(e.end)(e.l)(e.r)(e.rollback) = ' if (!SLIDE('e.curr', 'e.end', ' e.l ', ' e.r ')) goto ' e.rollback ';\n';
}

/**
* (метакод) (переменная_от) (переменная_по) (метка_для_отката_если_не_сопоставится) -> (код)(точка_отката)
*
*  метакод - метакод исходной программы, по которому строится результатный код
*  переменная_от - переменная, в которой хранится левый край сопостовляемой цепочки данных (перед первым элементом)
*  переменная_по -  --||-- правый край --||-- (последний элемент)

Если пусто, то переменная_от==переменная_по

*  метка_для_отката_если_не_сопоставится - метка кода, в которую нужно перейти, если текущий метакод не выполним для данных
*  ->
*  код - результатный код, для 'метакод'
*  точка_отката - точка возврата для всего метакода (в последний элемент)
*

l_varname и r_varname - границы значения переменной: перед левым элементом и правый элемент соответственно
Если значение пусто, то l_varname = r_varname - "перед пусто"
**/
//Build { (e.meta) e.e = <Prout e.meta> <Build_ (e.meta) e.e>}
Build {

	/*  [ e. ]   [ E. ] */
	(&VAR.v)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.v::type : (word {"e"|"E"}),
		@.v::name : $empty
	=	
		( '//// e. \n' )( e.rollback_label );
		
	/*  [ e.1 ]   [ E.1 ] */
	(&VAR.v)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.v::type : (word {"e"|"E"})
	=
		(
		'//// [ e.1 ] \n'
                <DEF 'l_' <VarName @.v>>
                <DEF 'r_' <VarName @.v>>
                <SET ('l_' <VarName @.v>)(e.arg_prefrom)>
                <SET ('r_' <VarName @.v>)(e.arg_to)>
		)(e.rollback_label);


	/*  [ e.1 <any> ] */
	(&VAR.v e.next)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.v::type : (word "e"),
		<VarName @.v> : e.vname,
		<RandomIdName> : e.lbl,
		<Build (e.next)('r_' e.vname)(e.arg_to)('label_' @.lbl)> : (e.next_code)(e.next_rollback)			=
		(
		'//// [ e.1 <any> ] \n'
                <DEF 'l_' e.vname>
                <DEF 'r_' e.vname>
                <SET ('l_' e.vname)(e.arg_prefrom)> // перед первым
                <SET ('r_' e.vname)(e.arg_prefrom)> // перед первым
                <JMP 'label_' @.lbl '_firststep'>
                <LABEL 'label_' @.lbl>
		<INC ('r_' e.vname)(e.arg_to)(e.rollback_label)>
		<LABEL 'label_' @.lbl '_firststep'>
		@.next_code
		)(e.next_rollback);


	/*  [ E.1 <any> ] */
	(&VAR.v e.next)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.v::type : (word "E"),
		<VarName @.v> : e.vname,
		<RandomIdName> : e.lbl,
		<Build (e.next)('r_' e.vname)(e.arg_to)('label_' @.lbl)> : (e.next_code)(e.next_rollback)
			=
		(
		'//// [ E.1 <any> ] \n'
                <DEF 'l_' e.vname>
                <DEF 'r_' e.vname>

                <SET ('l_' e.vname)(e.arg_prefrom)> // перед первым
                <SET ('r_' e.vname)(e.arg_to)> // последний
                <JMP 'label_' @.lbl '_firststep'>
                <LABEL 'label_' @.lbl>
		<DEC ('r_' e.vname)(e.arg_to)(e.rollback_label)>
		<LABEL 'label_' @.lbl '_firststep'>
		@.next_code
		)(e.next_rollback);


	/*  [ s.1 <any> ] */
	(&VAR.v e.next)( e.arg_from )( e.arg_to )( e.rollback_label ),
		@.v::type : (word "s"),
		<VarName @.v> : e.vname,
		<RandomIdName> : e.l_tmp,
		<Build (e.next)('r_' e.vname)(e.arg_to)(e.rollback_label)> : (e.next_code)(e.next_rollback)
			=
		(
		'//// [ s.1 <any> ] \n'
		<DEF e.l_tmp>
                <DEF 'l_' e.vname>
                <DEF 'r_' e.vname>
                <SET ('l_' e.vname)(e.arg_from)>
                <SET (e.l_tmp)(e.arg_from)>
                <INC (e.l_tmp)(e.arg_to)(e.rollback_label)>
                <SYMBOLP (e.l_tmp)(e.rollback_label)>
                <SET ('r_' e.vname)(e.l_tmp)>
		@.next_code
                )(e.next_rollback);


	/*  [ {...}.varname <any> ] */
	(&VAR.v e.next)( e.arg_from )( e.arg_to )( e.rollback_label ),
		@.v::type : GROUP_OR_VARIANT. ,
		<VarName @.v> : e.vname,
		<RandomIdName> : e.l_tmp,
		<Build (e.next)('r_' e.vname)(e.arg_to)(e.rollback_label)> : (e.next_code)(e.next_rollback)
			=
		(
		'//// [ s.1 <any> ] \n'
		<DEF e.l_tmp>
                <DEF 'l_' e.vname>
                <DEF 'r_' e.vname>
                <SET ('l_' e.vname)(e.arg_from)>
                <SET (e.l_tmp)(e.arg_from)>
                <INC (e.l_tmp)(e.arg_to)(e.rollback_label)>
                <SYMBOLP (e.l_tmp)(e.rollback_label)>
                <SET ('r_' e.vname)(e.l_tmp)>
		@.next_code
                )(e.next_rollback);


	/* [ &.name <any> ]  */
	(&LNK.l e.next)( e.arg_from )( e.arg_to )( e.rollback_label ),
		@.l::path : $empty,
		@.l::name : (t. e.vname),
		<RandomIdName> : e.r_tmp,
		<Build (e.next)(e.r_tmp)(e.arg_to)(e.rollback_label)> : (e.next_code)(e.next_rollback)
		=
		(
		'//// [ &.name <any> ] \n'
		<DEF e.r_tmp>
                <SET (e.r_tmp)(e.arg_from)>
                <SLIDE (e.r_tmp)(e.arg_to)('l_'@.vname)('r_'@.vname)(e.rollback_label)>
		@.next_code
                )(e.next_rollback);

	/* [ 'a' <any> ] */
	(&SYMBOL.s e.next)( e.arg_from )( e.arg_to )( e.rollback_label ),
		@.s : (t.type e.value),
		<RandomIdName> : e.r_tmp,
		<Build (e.next)(e.r_tmp)(e.arg_to)(e.rollback_label)> : (e.next_code)(e.next_rollback)
	=
		(
		'//// [ `a` <any> ] \n'
		<DEF e.r_tmp>
                <SET (e.r_tmp)(e.arg_from)>
                <INC (e.r_tmp)(e.arg_to)(e.rollback_label)>
                <EQSYM @.s ( e.r_tmp )(e.arg_to)( e.rollback_label )>
		@.next_code
                )(e.next_rollback);



	/* [ ( <any> ) <any> ] */
	(("(" e.into) e.next)( e.arg_from )( e.arg_to )( e.rollback_label ),
        <RandomIdName> : e.lrand,
        <RandomIdName> : e.l_tmp0,
        <RandomIdName> : e.r_tmp0,	
		<Build  (e.into )(e.l_tmp0)(e.r_tmp0)(e.rollback_label)> : (e.bracket_code)(e.bracket_rollback),
		<Build  (e.next)( e.lrand )( e.arg_to )(e.bracket_rollback)> : (e.next_code)(e.next_rollback)  /* возможно, откат идет от рефал-условия и нужно переопределить внутренности скобок */
//		<Build  (e.next)( e.arg_from )( e.arg_to )(e.bracket_rollback)> : (e.next_code)(e.next_rollback)  /* возможно, откат идет от рефал-условия и нужно переопределить внутренности скобок */
	=
		(
		'//// [ (<any>) <any> ] \n'
                <DEF e.lrand>
                <DEF e.l_tmp0>
                <DEF e.r_tmp0>
                <SET (e.lrand)(e.arg_from)>
                <INC (e.lrand)(e.arg_to)(e.rollback_label)>
                <ISBRACKET (e.lrand)(e.rollback_label)>
		<JMP_BRACKET ( e.lrand)(e.l_tmp0)(e.r_tmp0)>
		e.bracket_code
                //<INC ('l_tmp')(e.arg_to)(e.rollback_label)>
		e.next_code
		)(e.next_rollback);

	/* empty */
	(  )( e.arg_from )( e.arg_to )( e.rollback_label ) =
		(
		'//// [ empty ] \n'
		<ISEMPTY ( e.arg_from )( e.arg_to )( e.rollback_label )>
		)( e.rollback_label );

}

Fname {
	"-"  = "Dec";
	"+"  = "Add";
	"*"  = "Mul";
	"/" = "Div";
	e.else = e.else;
}

SubstCompile {
	//t.ord e.e = 'printf("success ' t.ord '!");' '\n' 'return 0; \n';
    (e.ch) = ;
    (e.ch) &LNK.lnk e.next     =
                            e.ch'->append_copy(l_' <VarName &LNK.lnk> ', r_' <VarName &LNK.lnk> '); \n'
                            <SubstCompile (e.ch) @.next>;
    (e.ch) ("<" &SYMBOL.fn e.in) e.next,
        <RandomIdName> : e.v,
        @.fn : (t. e.fname) =
                            'DataChain* ' e.v ' = new DataChain(); \n'
                            'DataContainer* ' e.v'_execbr = newRefExecBrackets(' <Fname e.fname> ', ' e.v ', "'e.fname'");' '\n'
                            e.ch'->append('e.v'_execbr);' '\n'
                            <SubstCompile (e.v) e.in>
                            'context->pushExecuteCall(' e.v'_execbr);' '\n'
                            <SubstCompile (e.ch) e.next>;
    (e.ch) ("(" e.in) e.next,
        <RandomIdName> : e.v   =
                            'DataChain* ' e.v ' = new DataChain(); \n'
                            e.ch'->append(newRefStructBrackets(' e.v ')); \n'
                            <SubstCompile (e.v) e.in>
                            <SubstCompile (e.ch) e.next>;
    (e.ch) &SYMBOL.s e.next   =
                            e.ch'->append(' <SubstCompileSYMBOL @.s> '); \n'
                            <SubstCompile (e.ch) e.next>;
}

SubstCompileSYMBOL {
    ("word" t.w) =  'newRefWord("' <Escape <Explode t.w>> '")' ;
    ("int" t.w)  =  'newRefInteger(' t.w ')' ;
    ("text" e.t) =  'newRefText("' <Escape e.t> '")' ;
}

Escape {
	'\n' e.e = '\\n' <Escape e.e>;
	'\t' e.e = '\\t' <Escape e.e>;
	'\\' e.e = '\\\\' <Escape e.e>;
	'\'' e.e = '\\\'' <Escape e.e>;
	'"' e.e = '\\"' <Escape e.e>;
	s.s e.e = s.s  <Escape e.e>;
	= ;
}


Template theword ::= (word e.value);
Template theint  ::= (int e.value);
Template varname ::= { theword. | theint. } ;

Template FUNCTION ::=
	{"$"(word ENTRY)' '|}
	(word t.name) {' '|} ("{" BLOCK.body) {' '|};

Template TEMPLATE ::=
	(word Template) ' ' (word t.name) {' '|} ":" ":" "=" LEFT_PART.body ;

//Template BLOCK ::= SENTENCE.head ";" {' '|} { BLOCK. |}.tail ;
Template BLOCK ::= e.block ;
Template SENTENCE   ::=  LEFT_PART.left_part "=" RIGHT_PART.right_part ;


Template LEFT_PART  ::=  PATTERN.pattern { IFs. |}.conditions ;
Template RIGHT_PART ::=  SUBSTIT.pattern ;

Template IFs ::= {' '|} "," {' '|} IF.head {IFs.|}.tail;
/*Template IF  ::= e.substitution ":" E.pattern,
			<IsPattern  E.pattern>		: True,
			<IsSubstit  e.substitution>	: True;
*/
Template IF  ::=
	{ "$" ("word" {"NOT"|"not"}) ' ' | $empty }.isnot
	SUBSTIT.substitution ":" PATTERN.pattern;

Template PATTERN ::= e.e, <IsPattern @.e> : True ;
Template SUBSTIT ::= e.e, <IsSubstit @.e> : True ;

IsPattern_  { e.e, <IsPattern_ e.e> : e.res = e.res <Prout '<IsPattern  ' e.e '>   -->   ' e.res>; }
IsPattern { = True; L_ITEM. E.tail, <IsPattern E.tail> : True = True; E.else = False; };

IsSubstit_  { e.e, <IsSubstit_ e.e> : e.res = e.res <Prout '<IsSubstit  ' e.e '>   -->   ' e.res>; }
IsSubstit { = True; R_ITEM. E.tail, <IsSubstit @.tail> : True = True; E.else = False; };

Template L_ITEM ::=
	{ ' '| ("(" PATTERN. ) | VAR. | SYMBOL. | "!" } ;

Template R_ITEM ::=
	{ ' '| ("(" SUBSTIT. ) | ("<" SUBSTIT. ) | VAR. | SYMBOL. } ;

Template SYMBOL ::=
	{ theword. | (int e.) | (real e.) | (text e.) | "$" (word empty) } ;


/*
Template VAR    ::= {
	theword.type  	       SPECIFICATORS.specs  "." { varname. | }.name |
	GROUP_OR_VARIANT.type  SPECIFICATORS.specs  { "." varname. | }.name
};
*/


/*-----------------------------
без пути:
4	word.name
3	word.
4	word[x..y].name
3	word[x..y].
1	{...}
4	{...}.name
4	{...}[x..y].name
1	{...}[x..y]
2	@.name
2	@word.name
4	&.name
3	&.
4	&word.name
3	&word.
4	&[x..y].name
3	&[x..y].
4	&word[x..y].name
3	&word[x..y].

-------------------------------*/
// открытые и закрытые переменные
Template VAR    ::=
	{ theword. | "@"{theword.|} | "&"{theword.|} | GROUP_OR_VARIANT. }.type  SPECIFICATORS.specs {"."|}.dot { varname. | }.name VAR_PATH.path,
		// точка может отсутствовать только для безымянной группы/варианта
		@.type @.specs @.dot @.name: {
					("{" e.) @.specs  |					// 1
					"@" {theword.|} "." t.termname  |			// 2
					{ theword. | "&"{theword.|} | ("{" e.) } @.specs "." |	// 3
					{ theword. | ("{" e.) | "&"{theword.|} } @.specs "." t.termname2 // 4
					}
;

VarName {
    = ;
    (t. e.v) = @.v;
    &VAR.v, @.v::name : (t. e.n) = e.n;
    VAR.v, @.v::name : (t. e.n) = e.n;
    &LNK.v, @.v::name : (t. e.n) = e.n;
    VAR.v, @.v::name : $empty = <RandomIdName>;
}



Template LNK    ::= {'@'|'&'}.type '.' varname.name VAR_PATH.path;  // шаблон для работы с закрытими переменными-указателями
Template VAR_PATH ::= { ":" ":" varname. VAR_PATH. | $empty } ;
Template GROUP_OR_VARIANT ::= ("{" e.body) ; //todo: уточнить
Template SPECIFICATORS ::= { { REPEATER. }.head SPECIFICATORS.tail |} ;
Template REPEATER ::= ("[" e.); // todo: уточнить






TokensToTree {
	FUNCTION.f  {";" |} E.next = <Prout 'Function: ' @.f::name>  <SEMANTIC &FUNCTION.f > <TokensToTree @.next>;
	TEMPLATE.tm  ";"  E.next   = <Prout 'Template: ' @.tm::name> <SEMANTIC &TEMPLATE.tm> <TokensToTree @.next>;
	' ' e.e = <TokensToTree e.e>;
	$empty = $empty;

	// ОШИБКИ
	e.error { TEMPLATE. ";" | FUNCTION.}.fnd E.next = <TokensToTree e.error> <TokensToTree @.fnd @.next>;
	//e.A TEMPLATE.tm  ";" E.next = <TokensToTree e.A> &TEMPLATE.tm <TokensToTree @.next>;
	//e.A FUNCTION.f   {";"|} E.next = <TokensToTree e.A> &FUNCTION.f <TokensToTree @.next>;
	e.else = <ProutError 'Error Function or Template definition:\n\n' e.else '\n\n'><Exit 9>;
};

// Семантический анализ
SEMANTIC {
	&FUNCTION.f  e.next
			=
				("FUNCTION" @.f::name
					<Sentences FUNCTION.f::body>
				)
				<SEMANTIC e.next>;

	&TEMPLATE.t  e.next,
		<PatternAnalise     ( )( )         TEMPLATE.t::body::pattern>    : (e.variables)(e.resultPattern),
		<ConditionsAnalise  (e.variables)()  <CondToList TEMPLATE.t::body::conditions>> : (e.variables2)(e.resultConditions)
			=
				("TEMPLATE" @.t::name
					("LEFT-PART"
						@.resultPattern
						@.resultConditions
					)
				)
				<SEMANTIC e.next>;

	$empty = $empty;
};


Sentences_ { e.e, <Sentences_ e.e> : e.result = e.result <Prout '<Sentences  ' e.e '> -->  ' e.result>; }
Sentences {
	{' '|} =;

	SENTENCE.sent ";" E.next,
		@.sent : LEFT_PART.left_part "=" RIGHT_PART.right_part,
		<PatternAnalise     ( )( )         LEFT_PART.left_part::pattern>    : (e.variables)(e.resultPattern),
		<ConditionsAnalise  (e.variables)()  <CondToList LEFT_PART.left_part::conditions>> : (e.variables2)(e.resultConditions),
		<SubstitutAnalise   (e.variables2)() RIGHT_PART.right_part> : (e.variables3)(e.resultConstitute)
		=	("SENTENCE" ("LEFT-PART" e.resultPattern  e.resultConditions)("RIGHT-PART" e.resultConstitute)) <Sentences E.next>;


	e.sent ";" E.else =
			<ProutError 'bad sentence: ' @.sent>
			<ProutError <FindErrorInSentence e.sent>>
			<Exit 9>
			<Sentences @.else>;

	SENTENCE.sent = <Sentences  @.sent ";">;

	e.else = <ProutError 'bad sentence: ' @.else><Exit 9>;
};


CondToList { =; IFs.conds = &IFs.conds::head <CondToList IFs.conds::tail> ; IF.c = &IF.c; e.else = <ProutError 'bad conditions: ' e.else><Exit 9>; }

GetLnkType { "&" e. = '&'; e. = '@'; }

//(e.vars)( ) e.substitution  =  (e.vars) (e.result);
SubstitutAnalise_ { e.e = <Prout '<SubstitutAnalise ' e.e '>'><SubstitutAnalise_ e.e>; };
SubstitutAnalise {
	// закрытая переменная
	(e.vars1 &VAR.exstvar e.vars2) (e.result) VAR.var e.otherpart,
		VAR.exstvar::name   		 : VAR.var::name,
		<GetLnkType VAR.var::type> '.' VAR.var::name VAR.var::path : LNK.lnk
		=
			<ErrorIfNotClosedVariable &VAR.var>
			<ErrorIfNotEqualType (VAR.exstvar::type)(VAR.var::type)('Different variables with the same name [1]: ' VAR.exstvar '  &  ' VAR.var ' . Types: '(VAR.exstvar::type)(VAR.var::type))>
			<SubstitutAnalise (e.vars1 &VAR.exstvar e.vars2)(e.result &LNK.lnk) e.otherpart>;

	(e.vars) (e.result) VAR.lnk e.otherpart
		=	//<ProutError  'Unexpected opened-variable in substitution: ' VAR.lnk '. Expected closed variables: '<UnPoint e.vars>>
			<SubstitutAnalise (e.vars)(e.result "$ERROR" 'Unexpected opened-variable in substitution: ' VAR.lnk '. Expected closed variables: '<UnPoint e.vars>) e.otherpart ' .'>;

	(e.vars)(e.result) ({"<"|"("}.sig SUBSTIT.subs ) e.otherpart,
		<SubstitutAnalise (e.vars)() SUBSTIT.subs> : (e.vars1)(e.res1)
		=	<SubstitutAnalise (e.vars1)(e.result (@.sig e.res1)) e.otherpart>;

	(e.vars)(e.result) ' ' e.otherpart
		=	<SubstitutAnalise (e.vars)(e.result) e.otherpart>;

	(e.vars) (e.result) SYMBOL.s e.next	=	<SubstitutAnalise (e.vars) (e.result &SYMBOL.s) e.next>;
	(e.vars) (e.result)			=	(e.vars) (e.result);
	(e.vars) (e.result) e.else		=
							//<ProutError  'Unknown item for SubstitutAnalise: \n\t' e.else >
							(e.vars)(e.result "$ERROR"  'Unknown item for substitution expression here: \t' e.else);

}

UnPoint {
	&VAR.v e.e = VAR.v <UnPoint e.e>;
	=;
}


//(e.vars)( ) e.leftpart = (e.vars) (e.leftpart);
PatternAnalise_ { e.e, <PatternAnalise_ e.e> : e.res = <Prout '<PatternAnalise ' e.e '>  --->  'e.res> e.res; }
PatternAnalise {
	// скобка
	(e.vars) (e.result) ("(" e.data) e.next,
		<PatternAnalise (e.vars)() e.data> : (e.mkvars)(e.mkdata)
		=	<PatternAnalise (e.mkvars)(e.result ("(" e.mkdata)) e.next>;

	// закрытая переменная
	(e.vars1 &VAR.exsvar e.vars2) (e.result) VAR.var e.otherpart,
		VAR.exsvar::name		 : VAR.var::name,
		<GetLnkType VAR.exsvar::type> '.' VAR.var::name VAR.var::path : LNK.lnk
		=
			<ErrorIfNotClosedVariable &VAR.var>
			<ErrorIfNotEqualType (VAR.exsvar::type)(VAR.var::type)('Different variables with the same name [2]: ' VAR.exsvar '  &  ' VAR.var)>
			<PatternAnalise (e.vars1 &VAR.exsvar e.vars2)(e.result &LNK.lnk) e.otherpart>;

	////// ОТКРЫТЫЕ ПЕРЕМЕННЫЕ:
	// открытая переменная с именем
	(e.vars) (e.result) VAR.var e.otherpart,
		$NOT VAR.var::name : $empty,
		<PatternAnaliseVar (e.vars) &VAR.var> : (e.mkvars) &VAR.mkvar
		=
			<ErrorIfNotOpenedVariable &VAR.var>
			<PatternAnalise (e.mkvars &VAR.var)(e.result &VAR.mkvar) e.otherpart>;

	// открытая безымянная переменная
	(e.vars) (e.result) VAR.var e.otherpart,
		VAR.var::name : $empty,
		<PatternAnaliseVar (e.vars) &VAR.var> : (e.mkvars) &VAR.mkvar
		=	<PatternAnalise (e.mkvars)(e.result &VAR.mkvar) e.otherpart>;

	(e.vars) (e.result) VAR.var e.otherpart	=	<ProutError 'unparsed variable: ' @.var>;
	(e.vars) (e.result) ' ' e.next		=	<PatternAnalise (e.vars) (e.result) e.next>;
	(e.vars) (e.result) SYMBOL.s e.next	=	<PatternAnalise (e.vars) (e.result &SYMBOL.s) e.next>;
	(e.vars) (e.result)			=	(e.vars) (e.result);
	(e.vars) (e.result) "!" e.next		=	<PatternAnalise (e.vars) (e.result "$cutter") e.next>;
	(e.vars) (e.result) e.else		=
							//<ProutError 'Unknown item for PatternAnalise: [' e.else ']'>
							(e.vars) (e.result "$ERROR" 'Unknown item for pattern here: \t' e.else);
}


ErrorIfNotOpenedVariable_ { e.e = <Prout e.e><ErrorIfNotOpenedVariable_ e.e>; };
ErrorIfNotOpenedVariable {
	&VAR.var, $NOT @.var::path  :   $empty	=	//<ProutError 'unexpected closed variable [1]: ' @.var>
							"$ERROR" 'unexpected closed variable [1]: ' @.var;
	&VAR.var, @.var::type  :  '@' E.	=	//<ProutError 'unexpected closed variable [2]: ' @.var>
							"$ERROR" 'unexpected closed variable [2]: ' @.var;
	&VAR.var = ;
}


ErrorIfNotClosedVariable {
	&VAR.var, $NOT @.var::specs :  $empty =		//<ProutError 'unexpected specificator in variable: ' @.var>
							"$ERROR" 'unexpected specificator in variable: ' @.var;
	&VAR.var, @.var::type  :  GROUP_OR_VARIANT. =	//<ProutError 'unexpected gruop: ' @.var >
							"$ERROR" 'unexpected gruop: ' @.var;
	&VAR.var = ;
}


// Для переменных-групп/вариантов выполняет PatternAnalise в body
PatternAnaliseVar_ { e.e,
	e.e : (e.v) &VAR.vv e.o,
	<Prout '<PatternAnaliseVar  ' @.vv '>'><PatternAnaliseVar_ e.e> : e.res
		=	<Prout '<PatternAnaliseVar  ' e.e '>  ---->  ' e.res> e.res;
}


PatternAnaliseVar {
	(e.vars) &VAR.var,
		VAR.var  : GROUP_OR_VARIANT.gtype e.vartail,
		<VariantToGroup <ForEachInBody_PatternAnalise (e.vars) @.gtype::body>> : (e.mkvars) e.mkbody,
		("{" e.mkbody) @.vartail    : VAR.mkvar
		=
			(e.mkvars) &VAR.mkvar;

	(e.vars) &VAR.var
		=	(e.vars) &VAR.var;

	e.else
		=
			<ProutError '[SYSTEMERROR] PatternAnaliseVar bad argument: ' e.else>
			<Exit 9>;
}

// (переменные)(тело_варианта)  =  (новые_переменные)метакод_тела
ForEachInBody_PatternAnalise {
	(e.vars) e.1 "|" e.2,
		<PatternAnalise (e.vars)() e.1> : (e.vars1)( e.result1),
		<ForEachInBody_PatternAnalise (e.vars) e.2> : (e.vars) e.meta
		= 	(e.vars)("|" e.result1) e.meta;  // переменные не изменяются

	(e.vars) e.1,
		<PatternAnalise (e.vars)( ) e.1> : (e.vars1) (e.result1)
		=	(e.vars)("|" e.result1);
}

VariantToGroup {
	(e.var)("|" e.body) = (e.var) e.body; // один вариант - это группа
	e.e = e.e;
}


// (e.vars)() &IF[...]   =  (e.vars-result)(e.result)
ConditionsAnalise_ { e.e, <ConditionsAnalise_ e.e> : e.res = e.res <Prout '<ConditionsAnalise ' e.e '>   -->  ' e.res>; }
ConditionsAnalise  {
	(e.vars)(e.result) = (e.vars)(e.result);

	(e.vars)(e.result) &IF.cond e.ifs,
		//<Prout '\n' &IF.cond '=\t'  IF.cond::substitution '\t:\t' IF.cond::pattern>:,
		<SubstitutAnalise (e.vars )( ) IF.cond::substitution> : (e.vars1)(e.subst1),
		<PatternAnalise   (e.vars1)( ) IF.cond::pattern     > : (e.vars2)(e.pattn2),
		<IF equal ( $empty )( IF.cond::isnot )  /* если нет отрицания условия */
			THEN  (e.vars2)(e.result ("IF" ("RIGHT-PART" e.subst1) ("LEFT-PART" e.pattn2)))
			ELSE  (e.vars )(e.result ("IF-"("RIGHT-PART" e.subst1) ("LEFT-PART" e.pattn2)))
		> : e.newarg
			=	<ConditionsAnalise e.newarg e.ifs>;
}

IF {
	equal (e.A)(e.A) THEN e.result ELSE e.	=	e.result;

	e. THEN e. ELSE e.result	=	e.result;
	E.else = <ProutError '[SYSTEMERROR] IF-function syntax error: <IF ' @.else '>'><Exit 9>;
}


ErrorIfNotEqualType {
	(e.1)(e.1)(e.error) = $empty;
	({"@"|"&"|} e.1)({"@"|"&"|} e.1)(e.error) = $empty;
	e. ("@") e. (e.error) = $empty;
	(e.1)(e.2)(e.error) = <ProutError '[SYSTEMERROR] ErrorIfNotEqualType: ' e.error>;
}

GetArgName {
	= <Prout '#### Bad .ref filename: '<Args>>;
}


DelComments_ {
	e.e = <Prout 'del: 'e.e><DelComments_ e.e>;
}

DelComments {
	{' '|} (comment e.comm) {' '|} e.e = <DelComments ' ' e.e>;
	( {"("|"{"|"["|"<"}.sig  e.1 ) e.e = (@.sig <DelComments e.1>) <DelComments e.e>;
	t.1 e.e = @.1 <DelComments e.e>;
	=;
}

PProut {
	(text e.e) e.next = "'" e.e "'" <PProut e.next>;
	( {int|word|real} e.e ) e.next = e.e <PProut e.next>;
	{' '|"."|"|"}.sym   e.next = @.sym <PProut e.next>;
	=;
	e.else = <ProutError 'PProut [' e.else ']'>;
}




Template META_IF ::= ({"IF"|"IF-"}.tag {("RIGHT-PART" e.)}.rp {("LEFT-PART" e.)}.lp );


// оптимизирует left_part и right_part в метакоде
// <OPTIMIZE_CHAIN (информация_для_оптимизации) хвост_оптимизируемой цепочки>
OPTIMIZE_CHAIN_ { e.e, <OPTIMIZE_CHAIN_ e.e> : e.res = e.res <Prout '<OPTIMIZE_CHAIN ' e.e '>  -->  ' e.res>; }
OPTIMIZE_CHAIN {
	(E.info) ({"("|"|"|"SENTENCE"}.br E.a) E.next
		=	(@.br  <OPTIMIZE_CHAIN (@.info) @.a>) <OPTIMIZE_CHAIN (@.info) @.next>;

	(E.info) SYMBOL.s E.next
		=	@.s <OPTIMIZE_CHAIN (@.info) @.next>;

	// оптимизация условий
	(E.info) META_IF.if  E.next
		=	(@.if::tag @.if::rp <OPTIMIZE_CHAIN (@.info) @.if::lp>) <OPTIMIZE_CHAIN (@.info) @.next>;

	// оптимизация последних еЕ-переменных
	(E.info) &VAR.var,
		@.var::type : ("word" {"e"|"E"}),
		("word" "END") @.var::specs @.var::dot @.var::name: VAR.endvar
		=	&VAR.endvar;

	// оптимизация, когда в паттерне последним идет группа или вариант с e-переменной в конце варианта
	(E.info) &VAR.var,
		@.var::type : GROUP_OR_VARIANT.gr ,
		("{"  <OPTIMIZE_CHAIN (@.info) @.gr::body>) @.var::specs @.var::dot @.var::name: VAR.endvar
		=	&VAR.endvar;

	/*(E.info) &VAR.var E.next,
		@.var::type : ("{" E.grup),
		("{" <OPTIMIZE_CHAIN (@.info) @.grup>) @.var::specs @.var::dot @.var::name: VAR.endvar
		=	&VAR.endvar <OPTIMIZE_CHAIN (@.info) @.next>;*/


	// прочие (последние) переменные не оптимизируются
	(E.info) &VAR.var E.next = &VAR.var <OPTIMIZE_CHAIN (@.info) @.next>;
	(E.info) &LNK.var E.next = &LNK.var <OPTIMIZE_CHAIN (@.info) @.next>;
	(E.info) &SYMBOL.item E.next = &SYMBOL.item <OPTIMIZE_CHAIN (@.info) @.next>;

	(E.info) =;

	(E.info) ("LEFT-PART" e.lp) E.next,
		@.lp : e.pattern { META_IF. E. }.ifs
		=	("LEFT-PART" <OPTIMIZE_CHAIN (@.info) @.pattern> <OPTIMIZE_CHAIN (@.info) @.ifs> )
			<OPTIMIZE_CHAIN (@.info) @.next> ;

	(E.info) ("LEFT-PART" e.pattern) E.next
		=	("LEFT-PART" <OPTIMIZE_CHAIN (@.info) @.pattern> )
			<OPTIMIZE_CHAIN (@.info) @.next> ;

	(E.info) ("RIGHT-PART" E.rp) E.next
		=	 ("RIGHT-PART" @.rp) <OPTIMIZE_CHAIN (@.info) @.next> ;

/*	(E.info) t.t E.next
		=
			t.t <OPTIMIZE_CHAIN (@.info) @.next>;
*/
	//E.else = @.else;
}



ProutError {
	e.e = <StdErr '#### ERROR: ' <META2TEXT e.e>>;
	//e.e = <ProutDebug '\n#### ERROR: ' <META2TEXT e.e>>;
}

META2TEXT_ { e.e = <ProutDebug '<META2TEXT ' e.e> <META2TEXT_ e.e>; }
META2TEXT {
	&VAR.v e.e = <META2TEXT @.v ' ' e.e>;
	&SYMBOL.v e.e = <META2TEXT @.v ' ' e.e>;
	&LNK.v e.e = <META2TEXT @.v ' ' e.e>;
	(word e.w)"."(word e.ww) e.e 		= 	<ExplodeAllN @.w>'.'<ExplodeAllN @.ww> <META2TEXT e.e>;
	(word e.w) e.e 		= 	<ExplodeAllN @.w>  <META2TEXT e.e>;
	(text e.w) e.e 		= 	'\''<ExplodeAllN @.w>'\'' <META2TEXT e.e>;
	(int  e.i) e.e		= 	    <ExplodeAllN @.i>' '  <META2TEXT e.e>;
	("|" e.e) = <META2TEXT e.e>;
	("|" e.v) e.next	=	<META2TEXT e.v> "|" <META2TEXT e.next>;
	( {"("|"{"|"["|"<"}.br e.w ) e.e,
		"(" ")" "{" "}" "[" "]" "<" ">" : e. @.br t.clbr e.
				=	<Explode @.br> <META2TEXT @.w> <Explode @.clbr> <META2TEXT e.e>;
	word.t e.e		=	<ExplodeAllN @.t> <META2TEXT e.e>;
	s.s e.e			=	s.s <META2TEXT e.e>;
	("$error" e.data)	=	<META2TEXT e.data>; // ошибка из RefalTockens
	=;
}

ExplodeAllN {
	e.e = <ExplodeAllN2 <ExplodeAll e.e>>;
}

ExplodeAllN2 {
	e.1 '\n' e.2 = e.1 ' ' <ExplodeAllN2 e.2>;
	e.e = e.e;
}

FindErrorInSentence {
	LEFT_PART.left_part "=" e.right_part,
		<PatternAnalise     ( )( )         LEFT_PART.left_part::pattern>    : (e.variables)(e.resultPattern),
		<ConditionsAnalise  (e.variables)()  <CondToList LEFT_PART.left_part::conditions>> : (e.variables2)(e.resultConditions),
		<SubstitutAnalise   (e.variables2)() @.right_part> : (e.) (e. "$ERROR" e.error) = e.error;

	e.left_part "," e.conds "=" RIGHT_PART.right_part,
		<PatternAnalise     ( )( )         @.left_part>    : (e.variables)(e.resultPattern),
		<ConditionsAnalise  (e.variables)()  <CondToList @.conds>> : e. "$ERROR" e.error = e.error;

	e.left_part "," e.conds "=" RIGHT_PART.right_part,
		<PatternAnalise     ( )( )         @.left_part>    : (e.) (e. "$ERROR" e.error) = e.error ;

	e.left_part "=" RIGHT_PART.right_part,
		<PatternAnalise     ( )( )         @.left_part>    : (e.) (e. "$ERROR" e.error) = e.error;

	e.lp "=" e.rp = 'left part and right part error: ' e.lp "=" e.rp;
	e. = '"=" - separator not found';
}

/*
	{ 'd' | 'dsd' | 'ssd' }


*/




