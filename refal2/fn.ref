$ENTRY Go {  = <Begin 100>; }

Begin {  
        0 = ;
	s.n =

	   <Prout 'Who is first? (1 - pc  2 - you)'>
	   <FirG <Card>>
	   <Begin <- s.n 1>>;
};

FirG {  '1' = <Game ('2')('1')('')('23456789')>;
	'2' = <Game ('2')('')('')('123456789')>;
	e.e = ;
};
/*
  Управление игрой.
  Применение ходов компьютера и человека, оформление игры.

*/

Game__ { e.e = <Prout "Game:" e.e><Game__ e.e>; };
Game {
		(s.g)(e.1)(e.2)(e.n) =
			<Ekran (e.1)(e.2)>
			<GameIfWin <Ifwin(e.1)(e.2)>(s.g)(e.1)(e.2)(e.n)>;
		e.e = ;
};

GameIfWin {
	 '0'e.e() = <Prout 'Nobody !!!.'>;
	 '1'e.e = <Prout 'Winner X'>;
	 '2'e.e = <Prout 'Winner O'>;
	 '0'e.e = <Game1 e.e>;
};


Game1__ {	e.e = <Prout "Game1:" e.e><Game1__ e.e>; };
Game1 {
	('1')e.12(e.n) = <Prout 'hmm ...'><Game ('2')<PlayerHod '1'<GetHod '1'('1')e.12(e.n)> e.12(e.n)>>;
	('2')e.12(e.n) = <Game ('1')<PlayerHod '2'<Prout 'Select number for 0:'><Card> e.12(e.n)>>;
};


PlayerHod__ {  e.e = <Prout "PlayerHod:" e.e><PlayerHod__ e.e>; };
PlayerHod {
   '1's.h (e.1)(e.2)(e.n1 s.h e.n2) = <Prout 'step:' s.h>(e.1 s.h)(e.2)(e.n1 e.n2);
   '2's.h (e.1)(e.2)(e.n1 s.h e.n2) = <Prout 'step:' s.h>(e.1)(e.2 s.h)(e.n1 e.n2);
   e.e=;
};



GetHod__ { e.e = <Prout "GetHod:" e.e><GetHod__ e.e>; };
GetHod {
	s.v e.e(e.not) =	<UseHod s.v e.e(e.not)(<WriteXO e.e('>'e.not)>)>;
};


UseHod__ { e.e = <Prout "UseHod:" e.e><UseHod__ e.e>; }
UseHod {e.e('#'s.s) = s.s;
	s.v e.e(e.not)(e.Wr) = <UHod(<Switch s.v e.Wr>)(e.Wr)(e.not)>;
};

UHod__ { e.e = <Prout "UHod:" e.e><UHod__ e.e>; }
UHod {
	(e.Sw)(e.Sw e.Wr)(s.s e.n) = s.s;
	(e.Sw)(s.s1'='s.s2 e.e e.Sw e.Wr)(s.s e.n) =
		<UHod (e.Sw)(e.e e.Sw e.Wr)(e.n)>;
};

Ekran { e.1 =
	    <Prout '*===T===T===*'>
	    <Prout '|'<XO '1'e.1>'|'<XO '2'e.1>'|'<XO '3'e.1>'|'>
	    <Prout '*===I===I===*'>
	    <Prout '|'<XO '4'e.1>'|'<XO '5'e.1>'|'<XO '6'e.1>'|'>
	    <Prout '*===I===I===*'>
	    <Prout '|'<XO '7'e.1>'|'<XO '8'e.1>'|'<XO '9'e.1>'|'>
	    <Prout '*===I===I===*'>
};

XO { s.1(e.21 s.1 e.22)(e.3) ='-X-';
     s.1(e.2)(e.31 s.1 e.32) ='-O-';
     s.1(e.2)(e.3) =s.1'  ';
};
* читает результаты вычислений и возвращает номер
* лучшего для указанного игрока хода
Switch { 0 = ;
	s.G s.A'='s.AA = s.A'='s.AA;
	s.G s.G'='s.AA s.G'='s.BB e.e = <Switch s.G s.G'='<Maix 'a' s.AA s.BB <Compare s.AA s.BB>> e.e>;
	s.G s.G'='s.AA s.s'='s.BB e.e = <Switch s.G s.G'='s.AA e.e>;
	s.G s.s'='s.AA s.G'='s.BB e.e = <Switch s.G s.G'='s.BB e.e>;
	s.G s.s'='s.AA s.s'='s.BB e.e = <Switch s.G s.s'='<Maix 'i' s.AA s.BB <Compare s.AA s.BB>> e.e>;
	e.e = <Prout 'Sw unk: 'e.e>;
};

Maix {
 'a' s.A s.B '-'= s.B;
 'a' s.A s.B '+'= s.A;
 'i' s.B s.A '-'= s.B;
 'i' s.B s.A '+'= s.A;
 e.e s.A s.zn = s.A;
};

* ----------------------------------------------------------------
* Записывает в поток 1 и возвращает результаты анализа всех ходов,
* следующих за знаком '>'
* WriteXO: <WriteXO ('кто')('1игрок')('2игрок')('>несход')>>;
* ->  a=b c=d ...
* ----------------------------------------------------------------

WriteXO__ { e.e = <Prout "WriteXO:" e.e><WriteXO__ e.e>; }
WriteXO { = ;
	(s.g)(e.1)(e.2)(e.n) =
		<WXOif (s.g)(<Strategy e.1>)(<Strategy e.2>)(<Strategy e.n>)(e.1)(e.2)(e.n)>;
};

WXOif__ { e.e = <Prout "WXOif:" e.e><WXOif__ e.e>; }
WXOif {
    ('1')e.eee1(e.1 s.A e.2 s.A e.3)e.eee2(e.n1 s.A e.n2)(e.e1)(e.e2)(e.n) =
		'#'<Lins (e.n)<AntiStrategy s.A>>;

    (s.g)e.e(e.1)(e.2)(e.n) = <WriteXO1 (s.g)(e.1)(e.2)(e.n)>;
};

Lins__ { e.e = <Prout "Lins:" e.e> <Lins__ e.e>; }
Lins { (e.n1 s.hod e.n2 ) e.as1 s.hod e.as2 = s.hod; };

AntiStrategy__ { e.e = <Prout "AntiStrategy:" e.e><AntiStrategy__ e.e>; }
AntiStrategy
{  '1' = '123';
   '2' = '456';
   '3' = '789';
   '4' = '147';
   '5' = '258';
   '6' = '369';
   '7' = '159';
   '8' = '357';
};

WriteXO1__ { e.e = <Prout "WriteXO1:" e.e><WriteXO1__ e.e>; };
WriteXO1 { = ;
	 e.eee(e.3'>') = ;
	 (s.g) e.eee(e.3'>'s.s e.4) =
		<Length<Optima21<Analiz (s.g) e.eee(e.3'>'s.s e.4)>>>
		<WriteXO (s.g) e.eee(e.3 s.s '>' e.4)>;
};

* возврат первого символа
First1 { s.1 e.2 = s.1; e.1 = e.1;};

* считает выгоду и возвращает его вместе
* с последним символом    'сим=колв'
Length__ { e.e = <Prout "Length:" e.e><Length__ e.e>; };
Length {
	e.1'12'e.2 = <DivS <First1<Lenw e.1'1'>> <First1<Lenw '2'e.2>> >;
	e.1'1'e.2 = '1='2000000;
	e.1'2'e.2 = '2='2000000;
		  = '1='1;
	e.1 = <Prout 'Length error symbols!!! : '><Print e.1>;
};

DivS { s.1  s.2  = <IfDiv <Compare s.1 s.2> s.1  s.2 >;
};
IfDiv { '+' s.1  s.2  = '1='<Div  s.1  s.2>;
	s.zn s.1 s.2  = '1='<Div  s.2  s.1>;
};

* Возвращает номер след-го игрока
NextPl { '1' = '2';
	 '2' = '1';
	 e.e=<Print 'NextPl uncn.: 'e.e>;
};

* Обработка 1 и 2 к удобному для подсчета виду
* (уничтожение пар)
Optima21 {e.e = /*<Prout '      ...'>*/<Optima211 e.e>};
Optima211 {  e.1'1'e.2'1'e.3 = '11'<Optima211 e.1 e.3>e.2;
	    e.1'1'e.2 = '1'<Optima211 e.1 e.2>;
	    e.1 = e.1;
};

Strategy__ { e.e = <Prout "Strategy:" e.e><Strategy__ e.e>; };
Strategy {   =;
	 e.1'1'e.2 = '147'<Strategy e.1 e.2>;
	 e.1'2'e.2 = '15'<Strategy e.1 e.2>;
	 e.1'3'e.2 = '168'<Strategy e.1 e.2>;
	 e.1'4'e.2 = '24'<Strategy e.1 e.2>;
	 e.1'5'e.2 = '2578'<Strategy e.1 e.2>;
	 e.1'6'e.2 = '26'<Strategy e.1 e.2>;
	 e.1'7'e.2 = '348'<Strategy e.1 e.2>;
	 e.1'8'e.2 = '35'<Strategy e.1 e.2>;
	 e.1'9'e.2 = '367'<Strategy e.1 e.2>;
	 e.1 = e.1;
};

Ifwin  {
  (e.1)(e.2) = /*<Putout 1 (e.1)(e.2)>*/<Ifwin1 (<Strategy e.1>)(<Strategy e.2>)>;
};
Ifwin1 {
	(e.1 s.A e.2 s.A e.3 s.A e.4)(e.e) = '1';
	(e.e)(e.1 s.A e.2 s.A e.3 s.A e.4) = '2';
	(e.1)(e.2) = '0';
};

* Анализ хода после знака '>'
Analiz__ { e.e = <Prout "Analiz:" e.e><Analiz__ e.e>; };
Analiz {
	e.1(e.3'>') = ;
* 	Организация передачи хода сопернику
	('1')(e.1)(e.2)(e.3'>'s.A e.4) =
			<PolnAnaliz('2')(e.1 s.A)(e.2)(e.3 e.4)>;
	('2')(e.1)(e.2)(e.3'>'s.A e.4) =
			<PolnAnaliz('1')(e.1)(e.2 s.A)(e.3 e.4)>;
	e.e = <Prout 'No point: 'e.e>;
};

PolnAnaliz__ { e.e = <Prout "PolnAnaliz:" e.e><PolnAnaliz__ e.e>; }
PolnAnaliz {
       (s.g)(e.1)(e.2)(e.n) =
	    <Ifmust (<Strategy e.1>)(<Strategy e.2>)(<Strategy e.n>)(s.g)(e.1)(e.2)(e.n)>;
};
Ifmust__ { e.e = <Prout "Ifmust:" e.e><Ifmust__ e.e>; };
Ifmust {
       (e.e1)(e.e21 s.A e.e22 s.A e.e23)(e.nn1 s.A e.nn2)('2')e.e1e2(e.n)='2';
       (e.e21 s.A e.e22 s.A e.e23)(e.e1)(e.nn1 s.A e.nn2)('1')e.e1e2(e.n)='1';
       (e.e1)(e.e21 s.A e.e22 s.A e.e23)(e.nn1 s.A e.nn2)('1')e.e1e2(e.n)=
	     <StepShag <Lins (e.n)<AntiStrategy s.A>>('1')e.e1e2(e.n) >;
       (e.e21 s.A e.e22 s.A e.e23)(e.e1)(e.nn1 s.A e.nn2)('2')e.e1e2(e.n)=
	     <StepShag <Lins (e.n)<AntiStrategy s.A>>('2')e.e1e2(e.n) >;

       (e.e1)(e.e2)(e.nn)e.hn = <PolnAnalizEny e.hn>;
};

StepShag {
       s.A ('1')(e.1)(e.2)(e.n1 s.A e.n2) =
		<PolnAnaliz('2')(e.1 s.A)(e.2)(e.n1 e.n2)>;
       s.A ('2')(e.1)(e.2)(e.n1 s.A e.n2) =
		<PolnAnaliz('1')(e.1)(e.2 s.A)(e.n1 e.n2)>;
};

PolnAnalizEny {
	(s.s)(e.1)(e.2)() = ;
	(s.s)(e.1)(e.2)(e.3'>') = ;
	(s.s)(e.I)(e.Y)(e.1'>'s.sss e.2) =
	      <Analiz (s.s)(e.I)(e.Y)(e.1 '>' s.sss e.2)>
	      <PolnAnaliz(s.s)(e.I)(e.Y)(e.1 s.sss '>' e.2)>;
	e.sIY(e.1) = <PolnAnaliz e.sIY('>'e.1)>;
};
