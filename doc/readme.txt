D-REFAL
Pre-Alpha версия диалекта языка Рефал.

Поддержка только латиницы
Нет сборки мусора
Препроцессор мало и плохо информативен ( изначально запланировано так - будет переписан на D-refal)
пока используется прерпоцессор на Рефале5
нет динамической дозагрузки программы
только одномодульный режим



########### Установка:

распакавать папку bin,
в переменных окружения создать переменную REFAL_HOME, указывающую на папку bin
добавить %REFAL_HOME% в переменную %path%




########### Запуск программ
выполнить рефал скрипт:  dref  program.ref




########### Синтаксис:
вот что уже сделано (остальное - см todo.txt)

1) s t e E - переменные, структурные скобки, Рефал-условия. Синтаксис как в рефале-5.
2) Закрытые (не свободные) переменные можно определять так:  @.varName (вместо имени типа - знак '@'.)
3) Безымянные переменные:   e.  s.  t.   E.  -  всегда открытые

4) спецификаторы:
	{  ....  }.name    -	групповые скобки (переменная, объединяющая часть шаблона). 
				Для достпа к значению использоовать @.name. Если безымянная, то точку нужно опустить.
	{  |  |  }.name    - 	вариант. всегда внутри фигурных скобок. Все открытые переменные внутри варианта не видны вне варианта.

	{  |  |  }[ 1..5 ].name - повторитель. При данном препроцессоре - только с фигурными скобками. 
				Диапазон задается числами (потом сделаю еще и закрытой переменной типа int). Пока нету infin и убывающего порядка

		Пример:	{ X | Y | Z }[2..4].var
		Приоритет:  XX XXX XXXX XXXY XXXZ XXY XXYX XXYY ... XY XYX XYXX XYXY ... XZZZ YX YXX YXXX YXXY ... ZZZX ZZZY ZZZZ
		

5)$not	-   отрицание условий.   
		$NOT ПраваяЧасть : Шаблон    
	или     
		ПраваяЧасть : $NOT Шаблон    
условие верно, только если оно не выполняется


6) пользовательские шаблоны:

		Template  ИмяШаблона ::=  ЛеваяЧасть ;		

	Рефал-программа - совокупность функций и пользовательских шаблонов (ПШ).
	Допустимы условия в левой части. Переменные e и E НЕ могут быть крайними в образце ПШ (пока только оговорено устно).
	После описания шаблона становится возможно его испольщования в качестве описания пременной:    e.  ИмяШаблона.tag E.
	Все свободные переменные тела шаблона доступны в левой части с переменной данного шаблона/типа. Использовать операцию разименования '::' :
	
	Template TAG ::= '<'TagName.name TagAttributes.attributes'>' XMLtext.value '</' TagName.name '>';
	Template TagName ::= {'a'|'b'|'c'|'d'}[1..256] ;    // в текущем препроцессоре поддерживаются варианты только с именами
	Template TagAttributes ::= TAttributes.head TagAttrib.last;
	Template TagAttrib ::= { | IdWord '=' qute. e. qute.};
	Template qute ::= { '"' | '\'' };

	Верно:
		F {
			e. TAG.myway E.  =  TAG.myway::attributes::last ;
			e. = ;
		}
	
		
7) !  -  отсечение (для образцов левых частей):
        '<'TagName.name '"' e.name '">' ! e.value  '</' TagName.name '>'
	
		Если программист уверен, что возможен только один правильный исход сопоставления слева от какой-то части образца, то он может 
	использовать отсечение. Откат отсечения приводит к неудаче сопоставления всего образца. Данный способ значительно ускоряет программу 
	(но это не инвариант!)





Исламов Марат. Ижевск. 
islamov.marat@gmail.com

