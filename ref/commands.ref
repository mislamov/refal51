/* перевод метакода в конечный исполнимый код */

DefFunction {
	t.name (e.code) = 
			<AppendFunction  t.name>

			'\n' 'DataChain* ' t.name '(DataCursor arg_from, DataCursor arg_to, ExecContext *context){' '\n'
			e.code

			'\n' '}' '\n';
}

DefTemplate {
	t.name (e.rollback_label)(e.subvars)(e.code) =  
		'\n' 'struct ' t.name '{' '\n' 
		'DataCursor var_' t.name '_l; ' '\n'
		'DataCursor var_' t.name '_r; ' '\n'
		'\\' e.subvars '\n'
		'\n' '}' '\n' 
				
		'\n' 'bool parse_' t.name '(DataCursor arg_from, DataCursor arg_to, RefMap *map, std::list<DataChain*> &chains){' '\n'
		'// подготовка к сопоставлению шаблона' '\n'
		'if (map!=0){ goto ' e.rollback_label '; }' '\n'
		'map = new RefMap(); //malloc(sizeof(RefMap));' '\n'
		e.code
		'fail: ' '\n'
		'// обработка неуспеха \n'
		'std::cout << "fail!" << __LINE__ << std::endl;' '\n'
		'return false;' '\n\n'
		'\n' '}' '\n';
}

/** объявление функции пользователя */
AppendFunction {
	e.fname  = 
		<File "include/res.h" 
			<Mount "include/res.h"> '\n' 
			'DataChain* ' @.fname '(DataCursor arg_from, DataCursor arg_to, ExecContext *context);' '\n'
		>;
}

DefSentence {
	t.order (e.left_code)(e.rigth_code)(e.chainname)  =
			'\n' '{' '\n' 
			'// сопоставление \n'
			e.left_code
			'\n'
			'// подстановка \n'
			e.rigth_code

			'return ' e.chainname ';' '\n'
			'}' '\n' 
			'sentence_after_' t.order ': ' '\n';
}

DefSentenceBlock {
	t.order (e.left_code)(e.block_code) =
			'\n' '{' '\n' 
			'// сопоставление \n'
			e.left_code
			'\n'
			'// передача управления блоку \n'
			e.block_code
			'}' '\n' 
			'sentence_after_' t.order ': ' '\n';
}

ReturnFail {
	=	
	'\n'  
	'// подготовка к возвращению неуспеха' '\n' 'std::cout << "fail!" << __LINE__ << "\\n";' '\n' 'return 0;' '\n';

}




/**
* код передвижения переменной по цепочке, ограниченной значением e.border
*/
INC {	(e.var)(e.border)(e.rollback_label) = '/*INC*/	if (!INC(' e.var ', ' e.border ')) goto ' e.rollback_label ';' '\n'}

/**
* код проверки завершения сопоставления
*/
ISEMPTY {	(e.l)(e.r)(e.rollback_label) = '/*ISEMPTY*/	if ('e.l'!=0 && ' e.r ' != ' e.l ') goto ' e.rollback_label ';' '\n'}


EQ {
    (e.v1)(e.v2)(e.roll)  =   'if (' e.v1 '!=' e.v2 ') goto ' e.roll;
}

CHAIN_FIRST {
	e.chain_var = e.chain_var'->at_before_first()';
}

CHAIN_LAST {
	e.chain_var = e.chain_var'->at_last()';
}

/*
* код проверки совпадения символаов по типу и значению
*/
EQSYM {
	("text" e.val)(e.var)(e.border)(e.rollback_label),
		<Compare <Lenw e.val> 1> : '+',
		<RandomIdName> : e.alphas,
		<RandomIdName> : e.texttmp
	=
		'\t' 'static DataChain *' e.texttmp ' = text_to_chain("' e.val '");' '\n'
		'\t' 'static DataCursor ' e.texttmp '_l = ' <CHAIN_FIRST e.texttmp> ';' '\n'
		'\t' 'static DataCursor ' e.texttmp '_r = ' <CHAIN_LAST e.texttmp> ';' '\n'
		<SLIDE (e.var)(e.border)(e.texttmp '_l')(e.texttmp '_r')(e.rollback_label)>;

	("text" s.value)(e.var)(e.border)(e.rollback_label),
		<RandomIdName> : e.alphas
	=
                '\t' 'if (' e.var '.container->type != text || *(' e.var '.container->value.text + 'e.var'.index) != \'' @.value '\') goto ' e.rollback_label ';\n';

	("int" e.value)(e.var)(e.border)(e.rollback_label)
	=
                '\t' 'if ('e.var '.container->type != integer || 'e.var '.container->value.num != ' e.value ') goto ' e.rollback_label ';\n';

	("word" e.value)(e.var)(e.border)(e.rollback_label)
	=
                '\t' 'if ('e.var '.container->type != word || 0!=memcmp('e.var '.container->value.word.value, "' e.value '", 'e.var '.container->value.word.leng)) goto ' e.rollback_label ';\n';

/*
	(t.type e.val)(e.var)(e.border)(e.rollback_label)
			=	'\t' 'if (('<TYPEP t.type e.var> ') || !(**' e.var ' == ' e.val ')) goto ' e.rollback_label ';\n';
*/
}


/*
* код проверки аргумента на то, является ли он структурной скобкой.
* Если да, то e.newfrom и e.newto - это смотрящие внутрь скобки переменные-границы'
*/
JMP_BRACKET {
	( e.br )(e.newfrom)(e.newto) =
			'//// JMP_BRACKET \n'
			'\t' e.newfrom' = 'e.br'.container->value.bracket_data.chain->at_before_first();' '\n'
			'\t' e.newto'   = 'e.br'.container->value.bracket_data.chain->at_last();' '\n'
}

ISBRACKET {
    (e.var)(e.rollback_label) =
	    '//// ISBRACKET \n'
	    '\t' 'if (' e.var '.container->type != struct_bracket) goto ' e.rollback_label ';' '\n';
}


/* простое присваивание */
SET {
    (e.var)(e.value) = '/*SET*/\t' e.var ' = ' e.value ';' '\n';
}

JMP {
    e.label = '/*JMP*/\t' 'goto ' e.label ';' '\n';
}

SYMBOLP {
    (e.var)(e.rollback) = '\t' 'if (! isSymbolType(' e.var '.container->type)) goto ' e.rollback ';\n';
}


DEF {
    e.var =
        '/*DEF*/\t' 'DataCursor ' e.var ';\n'
}

LABEL {
	e.lab = e.lab ': \n';
}
/* сравнение известной подцепочки с текущей */
SLIDE {
	(e.curr)(e.end)(e.l)(e.r)(e.rollback) = ' if (!SLIDE('e.curr', 'e.end', ' e.l ', ' e.r ')) goto ' e.rollback ';\n';
}



PrepareCodeFiles {
	=
	<File "include/res.h"
        '#include "direfal.h" \n'
        '#include "system.h" \n'
	'#include "evalutor.h" \n'
	'#include <list> \n'	
	>
}
WriteCodeToFile {
	e.asm = 

	<File "src/res.cc"
        '#include "direfal.h" \n'
        '#include "commands.h" \n'
        '#include "system.h" \n'
        '#include "res.h" \n'
	e.asm>;
}



VCOPY {
	(e.ch)(e.varname)	=	e.ch'->append_copy(l_' @.varname ', r_' @.varname ', context); \n'
}

/*
	(e.chain)(e.fname)(e.var)(e.context) e.arg_code -> (e.code_post) e.code
*/
EXEC {
	(e.chain)(e.fname)(e.var)(e.context) e.code	=
		()
		'DataChain* ' e.var ' = new DataChain(); \n'
		'DataContainer* ' e.var'_execbr = newRefExecBrackets(' <Fname e.fname> ', ' e.var ', "'e.fname'");' '\n'
		e.chain'->append('e.var'_execbr);' '\n'

		e.code

		e.context '->pushExecuteCall(' e.var'_execbr); ' '// ' e.fname '\n'

}

BRACKET {
	(e.chain)(e.var) e.code	=
		'DataChain* ' e.var ' = new DataChain(); \n'
		e.chain'->append(newRefStructBrackets(' e.var ')); \n'
		e.code
}

VALUE {
	(e.chain) (text) = ; // ''
	(e.chain) e.symbol	=
		e.chain'->append(' <SubstCompileSYMBOL @.symbol> '); \n'
}

SubstCompileSYMBOL {
    ("word" t.w) =  'newRefWord("' <Escape <Explode t.w>> '", __LINE__)' ;
    ("int" t.w)  =  'newRefInteger(' t.w ')' ;
    ("text" e.t) =  'newRefText("' <Escape e.t> '", __LINE__)' ;  // todo: придумать другое решение при использовании библиотечности
}

Escape {
	'\n' e.e = '\\n' <Escape e.e>;
	'\t' e.e = '\\t' <Escape e.e>;
	'\\' e.e = '//' <Escape e.e>;
	'\'' e.e = '\\\'' <Escape e.e>;
	'"' e.e = '\\"' <Escape e.e>;
	s.s e.e = s.s  <Escape e.e>;
	= ;
}

/*
	 (e.context) -> (e.chname) e.init_chain_code
*/
NEW_CHAIN {
	(e.context), 'chain_'<RandomIdName> : e.chname
	=	
		(e.chname)
		'// new chain \n'
		'DataChain *' e.chname ' = ' e.context '->putChain(); \n'
}

/*
	$empty -> (e.context) e.code
*/
NEW_CONTEXT {
	$empty, 
		'context_' <RandomIdName> : e.context  =  (e.context) 
			'ExecContext ' e.context '_static' '; \n' 
			'ExecContext *' e.context ' = &' e.context '_static; \n' ;			
}

/*
	(e.имя_цепочки)(e.new_prefrom)(e.new_to) -> e.code
*/
SET_CHAIN_CURSORS {
	(e.chname)(e.new_prefrom)(e.new_to) = 
		'// SET_CHAIN_CURSORS \n'
		e.new_prefrom ' = ' e.chname '->at_before_first(); \n'
		e.new_to ' = ' e.chname '->at_last(); \n'
}

FREE_CHAIN {
	(e.context) e.chname	=
		'// FREE_CHAIN ' e.chname '\n'
		e.context '->popChain(); \n'
}

/*
	вычисляет объектное выражение
*/
EVAL_CHAIN {
	(e.chname)(e.context)  =
		'// exeute' '\n'
		'execute(' @.context ', ' @.chname ');' '\n'
}
