/* Построение низкоуровнего мета-кода */

TreeToCode {
	("FUNCTION" e.funk) e.next =
				<TreeToCode_function e.funk>
				<TreeToCode e.next>;
	("TEMPLATE" e.templ) e.next =
				<TreeToCode_template e.templ>
				<TreeToCode e.next>;

	=;
}

TreeToCode_function {
	t.name e.e  =  <DefFunction t.name (<TreeToCode_sentences 1 e.e>)>
}

TreeToCode_template {
	t.name ("LEFT-PART" e.leftpart),
				<TreeToCode_LeftPart (e.leftpart)('arg_from')('arg_to')('fail')> : (e.code)(e.rollback_label) =
					<DefTemplate t.name 
						( e.rollback_label )
						( <DelDoubles <GetVars e.leftpart>> )
						( e.code )
					>
}

TreeToCode_sentences {
	t.order ("SENTENCE" ("LEFT-PART" e.leftpart)("RIGHT-PART" e.result)) e.e,
				<TreeToCode_LeftPart (e.leftpart)('arg_from')('arg_to')('sentence_after_' t.order)> : (e.code_lp)(e.rollback_label),
				<SubstitutionBuildNoEval e.result> : (e.result_name) e.code_rp
				=
						<DefSentence t.order (e.code_lp)(e.code_rp)(e.result_name)>
						<TreeToCode_sentences <Add 1 t.order> e.e>;

	0 = <Prout 'ERROR! EMPTY SENTENCE LIST'><Exit>;
	t.else	=	<ReturnFail>;
}



TreeToCode_LeftPart {
	(e.pattern ("IF" e.if) e.tail) ( e.arg_prefrom )( e.arg_to ) (e.rollback_label),
		<TreeToCode_Pattern (e.pattern)( e.arg_prefrom )( e.arg_to ) (e.rollback_label)> : (e.pattern_code)(e.rollback_pattern_label),
		<TreeToCode_AfterPattern (("IF" e.if) e.tail)(e.rollback_pattern_label)> : (e.tail_code)(e.rollback_tail_label)
		=	
			(
			'// pattern \n'
			e.pattern_code
			e.tail_code
			)(e.rollback_tail_label);


	(e.pattern) ( e.arg_prefrom )( e.arg_to ) (e.rollback_label)
		=
			<TreeToCode_Pattern (e.pattern)( e.arg_prefrom )( e.arg_to ) (e.rollback_label)>;
	
}


TreeToCode_AfterPattern {
	(("IF" ("RIGHT-PART" e.rp)("LEFT-PART" e.lp)) e.tail) (e.rollback_label),
	    <RandomIdName> : e.prefrom,
	    <RandomIdName> : e.to,    
	    <SubstitutionBuild (e.rp)(e.rollback_label)(e.prefrom)(e.to)>  : (e.rp_code) (e.rollback_RP) (e.chainname),
	    <TreeToCode_Pattern (e.lp)(e.prefrom)(e.to) (e.rollback_RP)>   : (e.lp_code) (e.rollback_lp_label),
	    <TreeToCode_AfterPattern (e.tail)(e.rollback_lp_label)>           : (e.tail_code) (e.tail_rollback_label)
		=	(
			'// substitute rigth part \n'
			e.rp_code
			'// left part \n'
			e.lp_code
			e.tail_code			
			) (e.tail_rollback_label);

	( )(e.rollback)
		=
			('// END TreeToCode_AfterPattern \n')(e.rollback);
}
			
		
		



/**
* (метакод) (переменная_от) (переменная_по) (метка_для_отката_если_не_сопоставится) -> (код)(точка_отката)
*
*  метакод - метакод исходной программы, по которому строится результатный код
*  переменная_от - переменная, в которой хранится левый край сопостовляемой цепочки данных (перед первым элементом)
*  переменная_по -  --||-- правый край --||-- (последний элемент)

Если пусто, то переменная_от==переменная_по

*  метка_для_отката_если_не_сопоставится - метка кода, в которую нужно перейти, если текущий метакод не выполним для данных
*  ->
*  код - результатный код, для 'метакод'
*  точка_отката - точка возврата для всего метакода (в последний элемент)
*

l_varname и r_varname - границы значения переменной: перед левым элементом и правый элемент соответственно
Если значение пусто, то l_varname = r_varname - "перед пусто"
**/
//TreeToCode_Pattern { (e.meta) e.e = <Prout e.meta> <Build_ (e.meta) e.e>}
TreeToCode_Pattern {

	/*  [ e. ]   [ E. ] */
	(&VAR.v)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.v::type : (word {"e"|"E"}),
		@.v::name : $empty
	=	
		( '//// e. \n' )( e.rollback_label );
		
	/*  [ e.1 ]   [ E.1 ] */
	(&VAR.v)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.v::type : (word {"e"|"E"})
	=
		(
		'//// [ e.1 ] \n'
                <DEF 'l_' <VarName @.v>>
                <DEF 'r_' <VarName @.v>>
                <SET ('l_' <VarName @.v>)(e.arg_prefrom)>
                <SET ('r_' <VarName @.v>)(e.arg_to)>
		)(e.rollback_label);


	/*  [ e.1 <any> ] */
	(&VAR.v e.next)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.v::type : (word "e"),
		<VarName @.v> : e.vname,
		<RandomIdName> : e.lbl,
		<TreeToCode_Pattern (e.next)('r_' e.vname)(e.arg_to)('label_' @.lbl)> : (e.next_code)(e.next_rollback)			=
		(
		'//// [ e.1 <any> ] \n'
                <DEF 'l_' e.vname>
                <DEF 'r_' e.vname>
                <SET ('l_' e.vname)(e.arg_prefrom)> // перед первым
                <SET ('r_' e.vname)(e.arg_prefrom)> // перед первым
                <JMP 'label_' @.lbl '_firststep'>
                <LABEL 'label_' @.lbl>
		<INC ('r_' e.vname)(e.arg_to)(e.rollback_label)>
		<LABEL 'label_' @.lbl '_firststep'>
		@.next_code
		)(e.next_rollback);


	/*  [ E.1 <any> ] */
	(&VAR.v e.next)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.v::type : (word "E"),
		<VarName @.v> : e.vname,
		<RandomIdName> : e.lbl,
		<TreeToCode_Pattern (e.next)('r_' e.vname)(e.arg_to)('label_' @.lbl)> : (e.next_code)(e.next_rollback)
			=
		(
		'//// [ E.1 <any> ] \n'
                <DEF 'l_' e.vname>
                <DEF 'r_' e.vname>

                <SET ('l_' e.vname)(e.arg_prefrom)> // перед первым
                <SET ('r_' e.vname)(e.arg_to)> // последний
                <JMP 'label_' @.lbl '_firststep'>
                <LABEL 'label_' @.lbl>
		<DEC ('r_' e.vname)(e.arg_to)(e.rollback_label)>
		<LABEL 'label_' @.lbl '_firststep'>
		@.next_code
		)(e.next_rollback);


	/*  [ s.1 <any> ] */
	(&VAR.v e.next)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.v::type : (word "s"),
		<VarName @.v> : e.vname,
		<RandomIdName> : e.l_tmp,
		<TreeToCode_Pattern (e.next)('r_' e.vname)(e.arg_to)(e.rollback_label)> : (e.next_code)(e.next_rollback)
			=
		(
		'//// [ s.1 <any> ] \n'
		<DEF e.l_tmp>
                <DEF 'l_' e.vname>
                <DEF 'r_' e.vname>
                <SET ('l_' e.vname)(e.arg_prefrom)>
                <SET (e.l_tmp)(e.arg_prefrom)>
                <INC (e.l_tmp)(e.arg_to)(e.rollback_label)>
                <SYMBOLP (e.l_tmp)(e.rollback_label)>
                <SET ('r_' e.vname)(e.l_tmp)>
		@.next_code
                )(e.next_rollback);


	/*  [ {...}.varname <any> ] */
	(&VAR.v e.next)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.v::type : GROUP_OR_VARIANT. ,
		<VarName @.v> : e.vname,
		<RandomIdName> : e.l_tmp,
		<TreeToCode_Pattern (e.next)('r_' e.vname)(e.arg_to)(e.rollback_label)> : (e.next_code)(e.next_rollback)
			=
		(
		'//// [ s.1 <any> ] \n'
		<DEF e.l_tmp>
                <DEF 'l_' e.vname>
                <DEF 'r_' e.vname>
                <SET ('l_' e.vname)(e.arg_prefrom)>
                <SET (e.l_tmp)(e.arg_prefrom)>
                <INC (e.l_tmp)(e.arg_to)(e.rollback_label)>
                <SYMBOLP (e.l_tmp)(e.rollback_label)>
                <SET ('r_' e.vname)(e.l_tmp)>
		@.next_code
                )(e.next_rollback);


	/* [ &.name <any> ]  */
	(&LNK.l e.next)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.l::path : $empty,
		@.l::name : (t. e.vname),
		<RandomIdName> : e.r_tmp,
		<TreeToCode_Pattern (e.next)(e.r_tmp)(e.arg_to)(e.rollback_label)> : (e.next_code)(e.next_rollback)
		=
		(
		'//// [ &.name <any> ] \n'
		<DEF e.r_tmp>
                <SET (e.r_tmp)(e.arg_prefrom)>
                <SLIDE (e.r_tmp)(e.arg_to)('l_'@.vname)('r_'@.vname)(e.rollback_label)>
		@.next_code
                )(e.next_rollback);

	/* [ 'a' <any> ] */
	(&SYMBOL.s e.next)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
		@.s : (t.type e.value),
		<RandomIdName> : e.r_tmp,
		<TreeToCode_Pattern (e.next)(e.r_tmp)(e.arg_to)(e.rollback_label)> : (e.next_code)(e.next_rollback)
	=
		(
		'//// [ `a` <any> ] \n'
		<DEF e.r_tmp>
                <SET (e.r_tmp)(e.arg_prefrom)>
                <INC (e.r_tmp)(e.arg_to)(e.rollback_label)>
                <EQSYM @.s ( e.r_tmp )(e.arg_to)( e.rollback_label )>
		@.next_code
                )(e.next_rollback);



	/* [ ( <any> ) <any> ] */
	(("(" e.into) e.next)( e.arg_prefrom )( e.arg_to )( e.rollback_label ),
        <RandomIdName> : e.lrand,
        <RandomIdName> : e.l_tmp0,
        <RandomIdName> : e.r_tmp0,	
		<TreeToCode_Pattern  (e.into )(e.l_tmp0)(e.r_tmp0)(e.rollback_label)> : (e.bracket_code)(e.bracket_rollback),
		<TreeToCode_Pattern  (e.next)( e.lrand )( e.arg_to )(e.bracket_rollback)> : (e.next_code)(e.next_rollback)  /* возможно, откат идет от рефал-условия и нужно переопределить внутренности скобок */
//		<TreeToCode_Pattern  (e.next)( e.arg_prefrom )( e.arg_to )(e.bracket_rollback)> : (e.next_code)(e.next_rollback)  /* возможно, откат идет от рефал-условия и нужно переопределить внутренности скобок */
	=
		(
		'//// [ (<any>) <any> ] \n'
                <DEF e.lrand>
                <DEF e.l_tmp0>
                <DEF e.r_tmp0>
                <SET (e.lrand)(e.arg_prefrom)>
                <INC (e.lrand)(e.arg_to)(e.rollback_label)>
                <ISBRACKET (e.lrand)(e.rollback_label)>
		<JMP_BRACKET ( e.lrand)(e.l_tmp0)(e.r_tmp0)>
		e.bracket_code
                //<INC ('l_tmp')(e.arg_to)(e.rollback_label)>
		e.next_code
		)(e.next_rollback);

	/* empty */
	(  )( e.arg_prefrom )( e.arg_to )( e.rollback_label ) =
		(
		'//// [ empty ] \n'
		<ISEMPTY ( e.arg_prefrom )( e.arg_to )( e.rollback_label )>
		)( e.rollback_label );

}

Fname {
	"-"  = "Dec";
	"+"  = "Add";
	"*"  = "Mul";
	"/" = "Div";
	e.else = e.else;
}


/*
    (e.метакод)(e.точка_отката)  =  (e.код)(e.новая_точка_отката)(e.chainname)
    compile and EVALUTE substitution!
*/
SubstitutionBuild {
	(e.code) (e.rollback)(e.new_prefrom)(e.new_to),
		'label_del_'<RandomIdName> : e.new_del_rollback, // 
		'label_nodel_'<RandomIdName> : e.new_label_nodel_rollback,
		<NEW_CHAIN> : (e.context) (e.chname) e.init_chain_code
		=
		(
			e.init_chain_code  // new chain(); Context context;
			<SubstituteCompile (e.context)(e.chname) e.code>  // append; append;
			<EVAL_CHAIN (e.chname)(e.context)> // execute(chain)
			<DEF e.new_prefrom>	
			<DEF e.new_to>
			<SET_CHAIN_CURSORS (e.chname)(e.new_prefrom)(e.new_to)>  // Cursor prefrom = chain->prefrom; to = chain->to;
			<JMP e.new_label_nodel_rollback>
			<LABEL e.new_del_rollback>  //  : del
			<FREE_CHAIN e.chname>  // chain->free; delete chain
			<JMP e.rollback> // goto last matching
			<LABEL e.new_label_nodel_rollback> // :next matching
		)(e.new_del_rollback)(e.chname);
}

/*
   e.meta-code  -> (e.chname) e.code
*/
SubstitutionBuildNoEval {
	e.code,
		<NEW_CHAIN> : (e.context) (e.chname) e.init_chain_code
		=
			(e.chname)
			e.init_chain_code  // new chain(); Context context;
			<SubstituteCompile (e.context)(e.chname) e.code>  // append; append;
		;
}

/*
   (e.context)(e.строящаяся_цепочка) e.метакод = <код>
*/
SubstituteCompile {
	//t.ord e.e = 'printf("success ' t.ord '!");' '\n' 'return 0; \n';
    (e.context)(e.ch) = ;
    (e.context)(e.ch) &LNK.lnk e.next	=
				<VCOPY (e.ch)(<VarName &LNK.lnk>)>
				<SubstituteCompile (e.context)(e.ch) @.next>;

    (e.context)(e.ch) ("<" &SYMBOL.fn e.in) e.next,
        <RandomIdName> : e.v,
        @.fn : (t. e.fname)	=				
				<EXEC (e.ch)(e.fname)(e.v)(e.context) <SubstituteCompile (e.context)(e.v) e.in> >
				<SubstituteCompile (e.context)(e.ch) e.next>;

    (e.context)(e.ch) ("(" e.in) e.next,
        <RandomIdName> : e.v	=
				<BRACKET (e.ch)(e.v) <SubstituteCompile (e.context)(e.v) e.in>>
				<SubstituteCompile (e.context)(e.ch) e.next>;

    (e.context)(e.ch) &SYMBOL.s e.next	=
				<VALUE (e.ch) @.s>
				<SubstituteCompile (e.context)(e.ch) e.next>;
}


/*PrepareSubstitutionBeforeCompile {
    (e.vars) E.next &LNK.lnk, 
			<Substitution_CanCut &LNK.lnk e.vars> : T 
			=   <PrepareSubstitutionBeforeCompile (@.vars) @.next> ("$cut" &LNK.lnk);

    (e.vars) E.next &LNK.lnk
			=	<PrepareSubstitutionBeforeCompile (@.vars) @.next> &LNK.lnk;

    (e.vars) E.next ( {"<"|"("}.br e.in),   
			<PrepareSubstitutionBeforeCompile (@.vars) @.in> : (@.newvars) @.newin
			=	<PrepareSubstitutionBeforeCompile (@.newvars) @.next> (@.br @.newin);

    (e.vars) E.next &SYMBOL.s 
			=	<PrepareSubstitutionBeforeCompile (@.vars) @.next> &SYMBOL.s;

    (e.vars) = (@.vars);
}*/


GetVars {
	&VAR.v e.e = @.v::name <GetVars e.e>;
	(e.1) e.e  = <GetVars e.1> <GetVars e.e>;
	t.1 e.e = <GetVars e.e>;
	=;
}
