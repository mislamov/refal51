
Template theword ::= (word e.value);
Template theint   ::= (int e.value);

Template varname ::= { theword. | theint. } ;


Template FUNCTION ::= 
	{"$"(word ENTRY)' '|}  
	(word t.name) {' '|} ("{" BLOCK.body) {' '|};

Template TEMPLATE ::=
	(word Template) ' ' (word t.name) {' '|} ":" ":" "=" LEFT_PART.body ;

Template BLOCK ::= SENTENCE.head ";" {' '|} { BLOCK. |}.tail ;
Template SENTENCE   ::=  LEFT_PART.left_part "=" RIGHT_PART.right_part ;


Template LEFT_PART  ::=  PATTERN.pattern { IFs. |}.conditions ;
Template RIGHT_PART ::=  SUBSTIT.pattern ;

Template IFs ::= "," IF.head {IFs.|}.tail;
/*Template IF  ::= e.substitution ":" E.pattern,
			<IsPattern  E.pattern>		: True,
			<IsSubstit  e.substitution>	: True;
*/
Template IF  ::= SUBSTIT.substitution ":" PATTERN.pattern;

Template PATTERN ::= e.e, <IsPattern @.e> : True ;
Template SUBSTIT ::= e.e, <IsSubstit @.e> : True ;

IsPattern_  { e.e, <IsPattern_ e.e> : e.res = e.res <Prout '<IsPattern  ' e.e '>   -->   ' e.res>; }
IsPattern { = True; L_ITEM. E.tail, <IsPattern E.tail> : True = True; E.else = False; };

IsSubstit_  { e.e, <IsSubstit_ e.e> : e.res = e.res <Prout '<IsSubstit  ' e.e '>   -->   ' e.res>; }
IsSubstit { = True; R_ITEM. E.tail, <IsSubstit @.tail> : True = True; E.else = False; };

Template L_ITEM ::=
	{ ' '| ("(" PATTERN. ) | VAR. | SYMBOL. } ;

Template R_ITEM ::=
	{ ' '| ("(" SUBSTIT. ) | ("<" SUBSTIT. ) | VAR. | SYMBOL. } ;

Template SYMBOL ::=
	{ theword. | (int e.) | (real e.) | (text e.) | "$" (word empty) } ;


/*
Template VAR    ::= {
	theword.type  	       SPECIFICATORS.specs  "." { varname. | }.name |
	GROUP_OR_VARIANT.type  SPECIFICATORS.specs  { "." varname. | }.name  
};
*/


/*-----------------------------
	word.name
	word.
	word[x..y].name
	word[x..y].
	{...}
	{...}.name
	{...}[x..y].name
-------------------------------*/
// открытые и закрытые переменные
Template VAR    ::=
	{ theword. | "@"{theword.|} | "&"{theword.|} | GROUP_OR_VARIANT. }.type  SPECIFICATORS.specs {"."|}.dot { varname. | }.name VAR_PATH.path,
		// точка может отсутствовать только для безымянной группы/варианта		
		@.type @.specs @.dot : { ("{" e.) @.specs | e. "." }
;
					
Template LNK    ::= '@.' varname.name VAR_PATH.path;  // шаблон для работы с закрытими переменными-указателями


Template VAR_PATH ::= { ":" ":" varname. VAR_PATH. | $empty } ;

Template GROUP_OR_VARIANT ::= ("{" e.body) ; //todo: уточнить

Template SPECIFICATORS ::= { { REPEATER. }.head SPECIFICATORS.tail |} ;
Template REPEATER ::= ("[" e.); // todo: уточнить




SELECT_ALLVAR {
	( E.a ) E.b = <SELECT_ALLVAR @.a>     <SELECT_ALLVAR @.b>;
	VAR.v   E.b = &VAR.v 		      <SELECT_ALLVAR @.b>;
	//&.point E.b = <SELECT_ALLVAR @.point> <SELECT_ALLVAR @.b>;
	s.1 E.b = <SELECT_ALLVAR @.b>;
	$empty = $empty;
};


PROGRAM {
	FUNCTION.f  {";" |} E.next = <Prout 'Function: ' @.f::name>  &FUNCTION.f  <PROGRAM @.next>;
	TEMPLATE.tm  ";"  E.next   = <Prout 'Template: ' @.tm::name> &TEMPLATE.tm <PROGRAM @.next>;
	' ' e.e = <PROGRAM e.e>;
	$empty = $empty;

	// ОШИБКИ
	e.error { TEMPLATE. ";" | FUNCTION.}.fnd E.next = <PROGRAM e.error> <PROGRAM @.fnd @.next>;
	//e.A TEMPLATE.tm  ";" E.next = <PROGRAM e.A> &TEMPLATE.tm <PROGRAM @.next>;
	//e.A FUNCTION.f   {";"|} E.next = <PROGRAM e.A> &FUNCTION.f <PROGRAM @.next>;
	e.else = <Prout 'Error Function or Template definition: ' e.else>;
};

// Семантический анализ
SEMANTIC {
	&FUNCTION.f e.next 
			= 
				("FUNCTION" @.f::name
					<Sentences FUNCTION.f::body> 
				)
				<SEMANTIC e.next>;
				
	&TEMPLATE.t e.next,
		<PatternAnalise     ( )( )         TEMPLATE.t::body::pattern>    : (e.variables)(e.resultPattern),
		<ConditionsAnalise  (e.variables)()  <CondToList TEMPLATE.t::body::conditions>> : (e.variables2)(e.resultConditions)
			= 
				("TEMPLATE" @.t::name
					("LEFT_PART"
						<PatternToXML    @.resultPattern>
						<ConditionsToXML @.resultConditions>
					)
				)
				<SEMANTIC e.next>;
	
	$empty = $empty;
};

Sentences {
	=;
	
	BLOCK.sents,
		BLOCK.sents::head : LEFT_PART.left_part "=" RIGHT_PART.right_part,
		<PatternAnalise     ( )( )         TLEFT_PART.left_part::pattern>    : (e.variables)(e.resultPattern),
		<ConditionsAnalise  (e.variables)()  <CondToList LEFT_PART.left_part::conditions>> : (e.variables2)(e.resultConditions),
		<SubstitutAnalise   (e.variables2)() RIGHT_PART.right_part> : (e.variables3)(e.resultConstitute)
		=	("SENTENCE" ("LEFT_PART" e.resultPattern  e.resultConditions)("RIGHT_PART" e.resultConstitute)) <Sentences BLOCK.sents::tail>;
		
	E.else = <Prout '#### ERROR SENTENCE: ' @.else>;
		
};


CondToList { =; IFs.conds = &IFs.conds::head <CondToList IFs.conds::tail> ; }

//(e.vars)( ) e.substitution  =  (e.vars) (e.result);
SubstitutAnalise {
	// закрытая переменная
	(e.vars1 &VAR.exsvar e.vars2) (e.result) VAR.var e.otherpart,
		VAR.exsvar::name   		 : VAR.var::name,
		'@.' VAR.var::name VAR.var::path : LNK.lnk
		=	
			<ErrorIfNotClosedVariable &VAR.var>
			<ErrorIfNotEqual (VAR.exsvar::type)(VAR.var::type)('Different variables with the same name: ' VAR.exsvar '  &  ' VAR.var)>
			<SubstitutAnalise (e.vars1 VAR.exsvar e.vars2)(e.result &LNK.lnk) e.otherpart>;

	(e.vars) (e.result) VAR.lnk e.otherpart
		=	
			<SubstitutAnalise (e.vars)(e.result "$ERROR" <Print 'Unexpected opened-variable in substitution: ' VAR.lnk>) e.otherpart>;

	(e.vars)(e.result) ({"<"|"("}	SUBSTIT.subs ) e.otherpart,
		<SubstitutAnalise (e.vars)() SUBSTIT.subs> : (e.vars1)(e.res1)
		=	<SubstitutAnalise (e.vars1)(e.result ("<" e.res1)) e.otherpart>;
		
	(e.vars)(e.result) ' ' e.otherpart
		=	<SubstitutAnalise (e.vars)(e.result) e.otherpart>;

	(e.vars) (e.result) SYMBOL.s e.next	=	<SubstitutAnalise (e.vars) (e.result &SYMBOL.s) e.next>;
	(e.vars) (e.result)			=	(e.vars) (e.result);
	(e.vars) (e.result) e.else		=	(e.vars)(e.result "$ERROR"  
								<Print 'Unknown item for SubstitutAnalise: [' e.else ']'>);
		
}




//(e.vars)( ) e.leftpart = (e.vars) (e.leftpart);
PatternAnalise_ { e.e, <PatternAnalise_ e.e> : e.res = <Prout '<PatternAnalise ' e.e '>  --->  'e.res> e.res; }
PatternAnalise {
	// скобка
	(e.vars) (e.result) ("(" e.data) e.next,
		<PatternAnalise (e.vars)() e.data> : (e.mkvars)(e.mkdata)
		=	<PatternAnalise (e.mkvars)(e.result ("(" e.mkdata)) e.next>;

	// закрытая переменная
	(e.vars1 &VAR.exsvar e.vars2) (e.result) VAR.var e.otherpart,
		VAR.exsvar::name		 : VAR.var::name,
		'@.' VAR.var::name VAR.var::path : LNK.lnk
		=	
			<ErrorIfNotClosedVariable &VAR.var>
			<ErrorIfNotEqual (VAR.exsvar::type)(VAR.var::type)('Different variables with the same name: ' VAR.exsvar '  &  ' VAR.var)>
			<PatternAnalise (e.vars1 VAR.exsvar e.vars2)(e.result &LNK.lnk) e.otherpart>;

	////// ОТКРЫТЫЕ ПЕРЕМЕННЫЕ:
	// открытая переменная с именем
	(e.vars) (e.result) VAR.var e.otherpart,
		$NOT VAR.var::name : $empty,
		<PatternAnaliseVar (e.vars) &VAR.var> : (e.mkvars) &VAR.mkvar
		=	
			<ErrorIfNotOpenedVariable &VAR.var>
			<PatternAnalise (e.mkvars &VAR.var)(e.result &VAR.mkvar) e.otherpart>;

	// открытая безымянная переменная
	(e.vars) (e.result) VAR.var e.otherpart,
		VAR.var::name : $empty,
		<PatternAnaliseVar (e.vars) &VAR.var> : (e.mkvars) &VAR.mkvar
		=	<PatternAnalise (e.mkvars)(e.result &VAR.mkvar) e.otherpart>;

	(e.vars) (e.result) VAR.var e.otherpart	=	<Prout '#### ERROR: unparsed variable: ' @.var>;
	(e.vars) (e.result) ' ' e.next		=	<PatternAnalise (e.vars) (e.result) e.next>;
	(e.vars) (e.result) SYMBOL.s e.next	=	<PatternAnalise (e.vars) (e.result &SYMBOL.s) e.next>;
	(e.vars) (e.result)			=	(e.vars) (e.result);
	(e.vars) (e.result) e.else		=	(e.vars) (e.result "$ERROR" <Print 'Unknown item for PatternAnalise: [' e.else ']'>);
							//<Prout '<PatternAnalise  ' (e.vars) (e.result) e.else '>'>;
}


ErrorIfNotOpenedVariable_ { e.e = <Prout e.e><ErrorIfNotOpenedVariable_ e.e>; };
ErrorIfNotOpenedVariable {
	&VAR.var, @.var::path  :  $not $empty = "$ERROR" <Print 'unexpected closed variable [1]: ' @.var>;
	&VAR.var, @.var::type  :  '@' E. = "$ERROR" <Print 'unexpected closed variable [2]: ' @.var>;
	&VAR.var = ;
}


ErrorIfNotClosedVariable {
	&VAR.var, @.var::specs :  $not $empty = "$ERROR" <Print 'unexpected specificator in variable: ' @.var>;
	&VAR.var, @.var::type  :  GROUP_OR_VARIANT. = "$ERROR" <Print 'unexpected gruop: ' @.var>;
	&VAR.var = ;
}


// Для переменных-групп/вариантов выполняет PatternAnalise в body
PatternAnaliseVar_ { e.e,
	e.e : (e.v) &VAR.vv e.o,
	<Prout '<PatternAnaliseVar  ' @.vv '>'><PatternAnaliseVar_ e.e> : e.res 
		=	<Prout '<PatternAnaliseVar  ' e.e '>  ---->  ' e.res> e.res;
}


PatternAnaliseVar {
	(e.vars) &VAR.var,
		VAR.var  : GROUP_OR_VARIANT.gtype e.vartail,
		<VariantToGroup <ForEachInBody_PatternAnalise (e.vars) @.gtype::body>> : (e.mkvars) e.mkbody,
		("{" e.mkbody) @.vartail    : VAR.mkvar		
		=
			(e.mkvars) &VAR.mkvar;
	
	(e.vars) &VAR.var
		=	(e.vars) &VAR.var;
		
	e.else 
		=	<Prout '####ERROR PatternAnaliseVar: ' e.else> <Exit 9>;
}

// (переменные)(тело_варианта)  =  (новые_переменные)метакод_тела
ForEachInBody_PatternAnalise {
	(e.vars) e.1 "|" e.2,
		<PatternAnalise (e.vars)() e.1> : (e.vars1)( e.result1),
		<ForEachInBody_PatternAnalise (e.vars) e.2> : (e.vars) e.meta
		= 	(e.vars)("|" e.result1) e.meta;  // переменные не изменяются
	
	(e.vars) e.1,
		<PatternAnalise (e.vars)( ) e.1> : (e.vars1) (e.result1)
		=	(e.vars)("|" e.result1);
}

VariantToGroup {
	(e.var)("|" e.body) = (e.var)(e.body); // один вариант - это группа
	e.e = e.e;
}


// (e.vars)() &IF[...]   =  (e.vars-result)(e.result)
ConditionsAnalise_ { e.e, <ConditionsAnalise_ e.e> : e.res = e.res <Prout '<ConditionsAnalise ' e.e '>   -->  ' e.res>; }
ConditionsAnalise  {
	(e.vars)(e.result) = (e.vars)(e.result);
	
	(e.vars)(e.result) &IF.cond e.ifs,
		//<Prout '\n' &IF.cond '=\t'  IF.cond::substitution '\t:\t' IF.cond::pattern>:,
		<SubstitutAnalise (e.vars )( ) IF.cond::substitution> : (e.vars1)(e.subst1),
		<PatternAnalise   (e.vars1)( ) IF.cond::pattern     > : (e.vars2)(e.pattn2)
			=	<ConditionsAnalise (e.vars2)(e.result ("IF" e.subst1 ":" e.pattn2)) e.ifs>;
}

// Template IF  ::= SUBSTIT.substitution ":" PATTERN.pattern;


ErrorIfNotEqual {
	(e.1)(e.1)(e.error) = $empty;
	(e.1)(e.2)(e.error) = <Prout '#### PARSER_ERROR: ' e.error>;
}


Go {
	= 
	<Prout 
		<META2XML
		<SEMANTIC <PROGRAM
			<Prout 'Delete comments...'>
			<DelComments <RefalTokens <Mount 'f.ref'>>>
//			<RefalTokens <Mount 'f.ref'>>
			<Prout 'done'>
		>>>
	>;
}

DelComments_ {
	e.e = <Prout 'del: 'e.e><DelComments_ e.e>;
}

DelComments {
	{' '|} (comment e.comm) {' '|} e.e = <DelComments ' ' e.e>;
	( {"("|"{"|"["|"<"}.sig  e.1 ) e.e = (@.sig <DelComments e.1>) <DelComments e.e>;
	t.1 e.e = @.1 <DelComments e.e>;
	=;
}

PProut {
	(text e.e) e.next = "'" e.e "'" <PProut e.next>;
	( {int|word|real} e.e ) e.next = e.e <PProut e.next>;
	{' '|"."|"|"}.sym   e.next = @.sym <PProut e.next>;
	=;
	e.else = <Prout 'error: [' e.else ']'>;
}




PatternToXML {
	e.e = e.e;
}

ConditionsToXML {
	e.e =e.e;
}



META2XML {
	( {"TEMPLATE"|"FUNCTION"}.type word.name E.body) E.next		=	
				'\n'
				'<' @.type 'name="' word.name '">'     
					<META2XML E.body>
				'</' @.type '>'
				<META2XML E.next>;


	( {"SENTENCE" | "LEFT_PART" | "RIGHT_PART" }.type  E.body) E.next
				=
				'\n\t''<'  @.type '>'
					<META2XML E.body>
				'</' @.type '>'
				<META2XML E.next>;

	{'\n' | '\t' | ' ' } E.next	=	
				<META2XML E.next>;
	
			
	("("  E.body) E.next	=
				'<BRACKET>'
					<META2XML E.body>
				'</BRACKET>'
				<META2XML E.next>;
				
	("<"  E.body) E.next	=
				'<EXEC>'
					<META2XML E.body>
				'</EXEC>'
				<META2XML E.next>;

	&SYMBOL.sym E.next	=
				<SYMBOL2XML @.sym>
				<META2XML E.next>;
			
	&LNK.var E.next		=	'<LNK>' @.var::thevar::name <PATH2XML @.var::path> '</LNK>';
	
	&VAR.var E.next		=
				<OPENVAR2XML @.var>
				<META2XML E.next>;
	
	("IF" e.lp ":" E.rp) E.next		=
				'<IF><RIGHT-PART>' 
					<META2XML @.lp> 
				'</RIGHT-PART><LEFT-PART>'
					<META2XML @.rp>
				'</LEFT-PART></IF>'
				<META2XML E.next>;
	
	=;
}

PATH2XML {
	= ;
	":" ":" E.next		=	'/' <PATH2XML E.next>;
	theword.w E.next	=	@.w::value <PATH2XML E.next>;
}

SYMBOL2XML {
	(word e.value) 	 =	'<WORD>' e.value '</WORD>';
	(int e.value ) 	 =	'<INT>'  e.value '</INT>';
	(real e.value) 	 =	'<REAL>' e.value '</REAL>';
	(text e.value) 	 =	'<TEXT>' e.value '</TEXT>';
	"$" (word empty) =	;
}

//&VAR[type specs dot name  ]
OPENVAR2XML {
	(word E.type)"."({word|int} E.name)	=	'<VAR>' @.type '.' @.name	'</VAR>';
	(word E.type)"."					=	'<VAR>' @.type '.'			'</VAR>';
	("{" ("|" E.variant) E.variants)	=	'<VARIANTS name="">' <META2XML E.variant>  <OPENVAR2XML E.variants> ;
	("{" ("|" E.variant) E.variants)"."({word|int} E.name)	=	'<VARIANTS name="' E.name '">' <META2XML E.variant>  <OPENVAR2XML E.variants> ;
	("|" E.body)		=	'<THE-VARIANT/>' <META2XML E.body> '</VARIANTS>';
	("|" E.body) E.next	=	'<THE-VARIANT/>' <META2XML E.body> <OPENVAR2XML E.next>;
	("{" (E.body))		=	'<GROUP name="">' <META2XML E.body> '</GROUP>';
	("{" (E.body))"."({word|int} E.name)		=	'<GROUP name="' E.name '">' <META2XML E.body> '</GROUP>';
	E.else				=	'<ERROR>Unresponsed variable: ' E.else '</ERROR>';
}



