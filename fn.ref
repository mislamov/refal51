
Template theword ::= (word e.value);
Template theint   ::= (int e.value);

Template varname ::= { theword. | theint. } ;


Template FUNCTION ::= 
	{"$"(word ENTRY)' '|}  
	(word t.name) {' '|} ("{" BLOCK.body) {' '|};

Template TEMPLATE ::=
	(word Template) ' ' (word t.name) {' '|} ":" ":" "=" LEFT_PART.body ;

Template BLOCK ::= SENTENCE.head ";" {' '|} { BLOCK. |}.tail ;
Template SENTENCE   ::=  LEFT_PART.left_part "=" RIGHT_PART.right_part ;


Template LEFT_PART  ::=  PATTERN.pattern { IFs. |}.conditions ;
Template RIGHT_PART ::=  SUBSTIT.pattern ;

Template IFs ::= "," IF.head {IFs.|}.tail;
Template IF  ::= SUBSTIT.substitution ":" PATTERN.pattern;

Template PATTERN ::= e. ;
Template SUBSTIT ::= e. ;

Template L_ITEM ::=
	{ ' '| ("(" PATTERN. ) | VAR. | LNK. | SYMBOL. } ;

Template R_ITEM ::=
	{ ' '| ("(" SUBSTIT. ) | ("<" SUBSTIT. ) | VAR. | LNK. | SYMBOL. } ;

Template SYMBOL ::=
	{ theword. | (int e.) | (real e.) | (text e.) | "$" (word empty) } ;


/*
Template VAR    ::= {
	theword.type  	       SPECIFICATORS.specs  "." { varname. | }.name |
	GROUP_OR_VARIANT.type  SPECIFICATORS.specs  { "." varname. | }.name  
};
*/


/*-----------------------------
	word.name
	word.
	word[x..y].name
	word[x..y].
	{...}
	{...}.name
	{...}[x..y].name
-------------------------------*/
Template VAR    ::=
	{ theword. | GROUP_OR_VARIANT. }.type  SPECIFICATORS.specs {"."|}.dot { varname. | }.name,
		// точка может отсутствовать только для безымянной группы/варианта		
		@.type @.specs @.dot : { ("{" e.) @.specs | e. "." }
;
					

Template LNK    ::=  { {  "@"{theword.|} | "&"{theword.|} | theword. }.type "." varname.name }.thevar  VAR_PATH.path ;   // использование @ обязательно!
Template VAR_PATH ::= { ":" ":" varname. VAR_PATH. | $empty } ;

Template GROUP_OR_VARIANT ::= ("{" e.body) ; //todo: уточнить

Template SPECIFICATORS ::= { { REPEATER. }.head SPECIFICATORS.tail |} ;
Template REPEATER ::= ("[" e.); // todo: уточнить




SELECT_ALLVAR {
	( E.a ) E.b = <SELECT_ALLVAR @.a>     <SELECT_ALLVAR @.b>;
	VAR.v   E.b = &VAR.v 		      <SELECT_ALLVAR @.b>;
	//&.point E.b = <SELECT_ALLVAR @.point> <SELECT_ALLVAR @.b>;
	s.1 E.b = <SELECT_ALLVAR @.b>;
	$empty = $empty;
};


PROGRAM {
	FUNCTION.f  {";" |} E.next = <Prout 'Function: ' @.f::name> &FUNCTION.f <PROGRAM @.next>;
	TEMPLATE.tm  ";" E.next = <Prout 'Template: ' @.tm::name> &TEMPLATE.tm <PROGRAM @.next>;
	' ' e.e = <PROGRAM e.e>;
	$empty = $empty;

	// ОШИБКИ
	e.1 TEMPLATE.tm  ";" E.next = <PROGRAM e.1> &TEMPLATE.tm <PROGRAM @.next>;
	e.1 FUNCTION.f   {";"|}  E.next = <PROGRAM e.1> &FUNCTION.f <PROGRAM @.next>;
	e.else = 'Error Function or Template definition: ' e.else;
};

// Семантический анализ
SEMANTIC {
	&FUNCTION.f e.next 
			= 
				'\n\n'
				("FUNCTION" @.f::name
					<Sentences FUNCTION.f::body> 
				)
				<SEMANTIC e.next>;
				
	&TEMPLATE.t e.next,
		<PatternAnalise     ( )( )         TEMPLATE.t::body::pattern>    : (e.variables)(e.resultPattern),
		<ConditionsAnalise  (e.variables)()  <CondToList TEMPLATE.t::body::conditions>> : (e.variables2)(e.resultConditions)
			= 
				'\n\n'
				("TEMPLATE" @.t::name
					("LEFT_PART"
						<PatternToXML    @.resultPattern>
						<ConditionsToXML @.resultConditions>
					)
				)
				<SEMANTIC e.next>;
	
	$empty = $empty;
};

Sentences {
	=;
	
	BLOCK.sents,
		BLOCK.sents::head : LEFT_PART.left_part "=" RIGHT_PART.right_part,
		<PatternAnalise     ( )( )         TLEFT_PART.left_part::pattern>    : (e.variables)(e.resultPattern),
		<ConditionsAnalise  (e.variables)()  <CondToList LEFT_PART.left_part::conditions>> : (e.variables2)(e.resultConditions),
		<SubstitutAnalise   (e.variables2)() RIGHT_PART.right_part> : (e.variables3)(e.resultConstitute)
		=	("SENTENCE" ("LEFT_PART" e.resultPattern  e.resultConditions)("RIGHT_PART" e.resultConstitute)) <Sentences BLOCK.sents::tail>;
		
	E.else = <Prout '#### ERROR SENTENCE: ' @.else>;
		
};


CondToList { =; IFs.conds = &IFs.conds::head <CondToList IFs.conds::tail>; }

//(e.vars)( ) e.substitution  =  (e.vars) (e.result);
SubstitutAnalise {
	// закрытая переменная
	(e.vars1 VAR.exsvar e.vars2) (e.result) VAR.var e.otherpart,
		VAR.exsvar::name   : VAR.var::name,
		'@.' VAR.var::name : LNK.lnk
		=	<ErrorIfNotEqual (VAR.exsvar::type)(VAR.var::type)('Different variables with the same name: ' VAR.exsvar '  &  ' VAR.var)>
			<SubstitutAnalise (e.vars1 VAR.exsvar e.vars2)(e.result "$ERROR" &LNK.lnk) e.otherpart>;

	(e.vars)(e.result) LNK.lnk e.otherpart 
		=	<SubstitutAnalise (e.vars)(e.result &LNK.lnk) e.otherpart>;
	
	(e.vars)(e.result) ({"<"|"("}	SUBSTIT.subs ) e.otherpart,
		<SubstitutAnalise (e.vars)() SUBSTIT.subs> : (e.vars1)(e.res1)
		=	<SubstitutAnalise (e.vars1)(e.result ("<" e.res1)) e.otherpart>;
		
	(e.vars)(e.result) ' ' e.otherpart
		=	<SubstitutAnalise (e.vars)(e.result) e.otherpart>;

	(e.vars) (e.result) SYMBOL.s e.next	=	<SubstitutAnalise (e.vars) (e.result &SYMBOL.s) e.next>;
	(e.vars) (e.result) = (e.vars) (e.result);
	(e.vars) (e.result) e.else		=	"$ERROR"  <Prout 'Unknown item for SubstitutAnalise: [' e.else ']'>;
		
}




//(e.vars)( ) e.leftpart = (e.vars) (e.leftpart);
PatternAnalise_ { e.e, <PatternAnalise_ e.e> : e.res = <Prout '<PatternAnalise ' e.e '>  --->  'e.res> e.res; }
PatternAnalise {
	// скобка
	(e.vars) (e.result) ("(" e.data) e.next,
		<PatternAnalise (e.vars)() e.data> : (e.mkvars)(e.mkdata)

		=	<PatternAnalise (e.mkvars)(e.result ("(" e.mkdata)) e.next>;

	// закрытая переменная
	(e.vars1 VAR.exsvar e.vars2) (e.result) VAR.var e.otherpart,
		VAR.exsvar::name   : VAR.var::name,
		'@.' VAR.var::name : LNK.lnk
		=	<ErrorIfNotEqual (VAR.exsvar::type)(VAR.var::type)('Different variables with the same name: ' VAR.exsvar '  &  ' VAR.var)>
			<PatternAnalise (e.vars1 VAR.exsvar e.vars2)(e.result &LNK.lnk) e.otherpart>;

	////// ОТКРЫТЫЕ ПЕРЕМЕННЫЕ:
	// открытая переменная с именем
	(e.vars) (e.result) VAR.var e.otherpart,
		$NOT VAR.var::name : $empty,
		<PatternAnaliseVar (e.vars) &VAR.var> : (e.mkvars) &VAR.mkvar
		=	<PatternAnalise (e.mkvars &VAR.var)(e.result &VAR.mkvar) e.otherpart>;

	// открытая безымянная переменная
	(e.vars) (e.result) VAR.var e.otherpart,
		VAR.var::name : $empty		=	<PatternAnalise (e.vars)(e.result &VAR.var) e.otherpart>;
	(e.vars) (e.result) VAR.var e.otherpart	=	<Prout '#### ERROR: unparsed variable: ' @.var>;
	(e.vars) (e.result) ' ' e.next		=	<PatternAnalise (e.vars) (e.result) e.next>;
	(e.vars) (e.result) SYMBOL.s e.next	=	<PatternAnalise (e.vars) (e.result &SYMBOL.s) e.next>;
	(e.vars) (e.result)			=	(e.vars) (e.result);
	(e.vars) (e.result) e.else		=	"$ERROR"  <Prout 'Unknown item for PatternAnalise: [' e.else ']'>;
}

// Для переменных-групп/вариантов выполняет PatternAnalise в body
PatternAnaliseVar_ { e.e,  
	e.e : (e.v) &VAR.vv e.o,
	<Prout '<PatternAnaliseVar  ' @.vv '>'><PatternAnaliseVar_ e.e> : e.res 
		=	<Prout '<PatternAnaliseVar  ' e.e '>  ---->  ' e.res> e.res;
}
PatternAnaliseVar {
	(e.vars) &VAR.var,
		VAR.var  : GROUP_OR_VARIANT.gtype e.vartail,
		<VariantToGroup <ForEachInBody_PatternAnalise (e.vars) @.gtype::body>> : (e.mkvars) e.mkbody,
		("{" e.mkbody) @.vartail    : VAR.mkvar		
		=
			(e.mkvars) &VAR.mkvar;
	
	(e.vars) &VAR.var
		=	(e.vars) &VAR.var;
		
	e.else 
		=	<Prout '####ERROR PatternAnaliseVar: ' e.else> <Exit 9>;
}

// (переменные)(тело_варианта)  =  (новые_переменные)метакод_тела
ForEachInBody_PatternAnalise {
	(e.vars) e.1 "|" e.2,
		<PatternAnalise (e.vars)() e.1> : (e.vars1)( e.result1),
		<ForEachInBody_PatternAnalise (e.vars) e.2> : (e.vars) e.meta
		= 	(e.vars)("|" e.result1) e.meta;  // переменные не изменяются
	
	(e.vars) e.1,
		<PatternAnalise (e.vars)( ) e.1> : (e.vars1) (e.result1)
		=	(e.vars)("|" e.result1);
}

VariantToGroup {
	(e.var)("|" e.body) = (e.var)(e.body); // один вариант - это группа
	e.e = e.e;
}


// (e.vars)() &IF[...]   =  (e.vars-result)(e.result)
ConditionsAnalise {
	(e.vars)(e.result) = (e.vars)(e.result);
	
	(e.vars)(e.result) &IF.cond e.ifs,
		<SubstitutAnalise (e.vars )( ) IF.cond::substitution> : (e.vars1)(e.subst1),
		<PatternAnalise   (e.vars1)( ) IF.cond::pattern     > : (e.vars2)(e.pattn2)
			=	<ConditionsAnalise (e.vars2)(e.result ("IF" e.subst1 ":" e.pattn2)) e.ifs>;
}

// Template IF  ::= SUBSTIT.substitution ":" PATTERN.pattern;


ErrorIfNotEqual {
	(e.1)(e.1)(e.error) = $empty;
	(e.1)(e.2)(e.error) = <Prout '#### PARSER_ERROR: ' e.error>;
}


Go {
	= <Prout 
		<META2XML
		<SEMANTIC <PROGRAM
			<Prout 'Delete comments...'>
//			<DelComments <RefalTokens <Mount 'f.ref'>>>
			<RefalTokens <Mount 'f.ref'>>
			<Prout 'done'>
		>>>
	>;
}

DelComments_ {
	e.e = <Prout 'del: 'e.e><DelComments_ e.e>;
}

DelComments {
	{' '|} (comment e.comm) {' '|} e.e = <DelComments ' ' e.e>;
	( {"("|"{"|"["|"<"}.sig  e.1 ) e.e = (@.sig <DelComments e.1>) <DelComments e.e>;
	t.1 e.e = @.1 <DelComments e.e>;
	=;
}

PProut {
	(text e.e) e.next = "'" e.e "'" <PProut e.next>;
	( {int|word|real} e.e ) e.next = e.e <PProut e.next>;
	{' '|"."|"|"}.sym   e.next = @.sym <PProut e.next>;
	=;
	e.else = <Prout 'error: [' e.else ']'>;
}




PatternToXML {
	e.e = e.e;
}

ConditionsToXML {
	e.e =e.e;
}



META2XML {
	( {"TEMPLATE"|"FUNCTION"}.type word.name E.body) E.next		=	
				'<' @.type 'name="' word.name '">'     
					<META2XML E.body>
				'</' @.type '>'
				<META2XML E.next>;


	( {"SENTENCE" | "LEFT_PART" | "RIGHT_PART" }.type  E.body) E.next
				=
				'\n''<'  @.type '>'
					<META2XML E.body>
				'</' @.type '>'
				<META2XML E.next>;

	{'\n' | '\t' | ' ' } E.next	=	
				<META2XML E.next>;
	
			
	("("  E.body) E.next	=
				'<BRACKET>'
					<META2XML E.body>
				'</BRACKET>'
				<META2XML E.next>;
				
	("<"  E.body) E.next	=
				'<EXEC>'
					<META2XML E.body>
				'</EXEC>'
				<META2XML E.next>;

	&SYMBOL.sym E.next	=
				<SYMBOL2XML @.sym>
				<META2XML E.next>;
			
	&LNK.var E.next		=	'<LNK>' @.var::thevar::name <PATH2XML @.var::path> '</LNK>';
	
	&VAR.var E.next		=
				<OPENVAR2XML @.var>
				<META2XML E.next>;
	
	=;
}

PATH2XML {
	= ;
	":" ":" E.next		=	'/' <PATH2XML E.next>;
	theword.w E.next	=	@.w::value <PATH2XML E.next>;
}

SYMBOL2XML {
	(word e.value) 	 =	'<WORD>' e.value '</WORD>';
	(int e.value ) 	 =	'<INT>'  e.value '</INT>';
	(real e.value) 	 =	'<REAL>' e.value '</REAL>';
	(text e.value) 	 =	'<TEXT>' e.value '</TEXT>';
	"$" (word empty) =	;
}

//&VAR[type specs dot name  ]
OPENVAR2XML {
	(word E.type)"."(word E.name)	=	'<VAR>' @.type '.' @.name '</VAR>';
	("{" (E.body))			=	'<GROUP name="">' <META2XML E.body> '</GROUP>';
	E.else				=	'<ERROR>Unresponsed variable: ' e.else '</ERROR>';
}



