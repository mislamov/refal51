// **********************************************
InputFile{='fn.ref';}
//InputFile{='t.ref';}

$Entry Go { = 

		<Prout<PostScan 
			<P2_Builder MODULE 
				<P1_Prescaning 
					()<P1_Prescaning_pre <Prout 'P1_Prescaning_pre'>
						0 '\n' <Mount <InputFile>>'\n' 
					><Prout 'P1_Prescaning'>
				><Prout 'P2_Builder'>
			>
		>>; 

		}



Template comment  ::= { '/*' e. '*/' | '//' e. '\n' } ! ;
Template Digit ::= { '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '0' };
Template Digits	  ::= Digit. { Digits. | } ! ;
Template Letter	  ::= { 'z'|'x'|'c'|'v'|'b'|'n'|'m'|'a'|'s'|'d'|'f'|'g'|'h'|'j'|'k'|'l'|'q'|'w'|'e'|'r'|'t'|'y'|'u'|'i'|'o'|'p'|
			'Z'|'X'|'C'|'V'|'B'|'N'|'M'|'A'|'S'|'D'|'F'|'G'|'H'|'J'|'K'|'L'|'Q'|'W'|'E'|'R'|'T'|'Y'|'U'|'I'|'O'|'P'| '-' | '_' 
			};


DoError { int.line END.text = <Print '#### ERROR [ line '@.line']: ' <Replace "$separator" ' ' @.text>> <Exit>; }
Replace { t.1 t.2 e.A t.1 e.B = e.A t.2 <Replace t.1 t.2 e.B>; t.1 t.2 e.e=e.e; }

// счет строк для сообщений об ошбках
P1_Prescaning_pre {
	int.line  e.pred '\n' END.next,
		<+ 1 int.line> : int.newline 
		=	@.pred  '\n'<Implode '$line:' @.newline> <P1_Prescaning_pre @.newline @.next>;
	int.line  END.next =  @.next <Implode '$line:' <+ 1 @.line>>;
}


Template separate  ::= { ' ' | '\t' | comment. | '\r' | '\n' | '$Entry' };
Template separateS ::= separate. { separateS. | } ! ;


/////////////////////////////////////////////////////////////
//   1.      prescaning-парсинг (чтение знаков языка)
/////////////////////////////////////////////////////////////
OtherBrack { '>'='<';'}'='{';']'='[';')'='('; }
ImplodeMeta { s.e=<Implode '$' s.e>; e.e=<Implode e.e>; }
P1_Prescaning0 { END.e = <Prout 'P1_Prescaning: [' @.e ']'><P1_Prescaning0 @.e>; }
P1_Prescaning {
	(E.code) separateS. END.next  
					=   <P1_Prescaning  (E.code "$separator") @.next>;
					
	(E.code) 
	{';'|'...'|'..'|'.'|'::='|'::'|':'|'='|'|'|'!'|'@'|','
	 |'+'|'-'|'*'|'/'
	 | '$NOT' | '$not'
	}.item  END.next 
					=  <P1_Prescaning  (E.code <ImplodeMeta @.item>) @.next>;
					
	(E.code) Digits.num  END.next  
					=  <P1_Prescaning  (E.code <Numb @.num>) @.next>; /// todo: вещественные в разных форматах
	(E.code) { Letter. e. }.word { s.notletter END.nn }.next,
		$NOT s.notletter : Letter. ,
		$NOT s.notletter : Digit.
					=   <P1_Prescaning  (E.code <Implode @.word>) @.next>;
					
	(E.code) '\'' e.all,
		<P1_Prescaning_quote ('\'') e.all> : (e.text) END.next
					=  <P1_Prescaning  (E.code ("text" e.text)) @.next>;

	(E.code) '"'  e.all,
		<P1_Prescaning_quote ( '"') e.all> : (e.text) END.next
					=  <P1_Prescaning  (E.code ("word" e.text)) @.next>;

	// начало скобочного выражения
	(E.code) {'{'|'['|'('|'<'}.br  END.next
					=  <P1_Prescaning  (E.code <Implode @.br' '>) @.next>;
	// конец скобочного выражения
	(E.code) {'}'|']'|')'|'>'}.br  END.next,
		<Implode <OtherBrack @.br>' '> : s.obr,
		@.code : E.A  s.obr  END.B
					=  <P1_Prescaning  (@.A (s.obr @.B)) @.next>;

	// проброс метакодов
	(E.code) word.l END.next,
		<Explode @.l> : '$' e.e 
					=  <P1_Prescaning  (E.code @.l) @.next>;
	
	(E.code) t.unknown e.text word.linelable END.next,
		<Explode  word.linelable>: '$line:' Digits.line
					=  <DoError <Numb @.line> 'Unexpected item `' @.unknown '` here : ' @.unknown @.text>;

	(E.code)  =  E.code; 
}

P1_Prescaning_quote {
	(t.qu E.text) t.qu END.next = (@.text) @.next;
	(t.qu E.text) '\\' s.metas END.next = <P1_Prescaning_quote (@.qu @.text <Unescape @.metas>) @.next>;
	(t.qu E.text) s.sym END.next = <P1_Prescaning_quote (@.qu @.text @.sym) @.next>;
	(t.qu E.text) t.s e.else1  word.linelable  END.else2,
		<Explode  word.linelable>: '$line:' Digits.line
		=	<DoError <Numb @.line> 'Unecpected text-symbol `'@.s'` here: ' @.s @.else1>;
	(t.qu E.text) END.else
		=	<DoError 0 'Unecpected text-symbol here: ' @.else>;
	END.e = <DoError 0 '<P1_Prescaning_quote  ' @.e ' > - ???'>;
}

Unescape {
	'\'' = '\'';
	'"' = '"';
	'n' = '\n';
	't' = '\t';
	'r' = '\r';
	'\\' = '\\';
}

//////////////////////////////////////////////////////////////////////////////////////////////
//   2.      структуризация и синтаксический анализ (генерация структуры программы)
//////////////////////////////////////////////////////////////////////////////////////////////

// ===== Переменные =====
// слово.имя ? (var (имя) слово)
// {цепь}.имя ? (group (имя) <S цепь>)
// {цепь}[F..T].имя ? (group (имя) (repeat F T <S цепь>))
// слово[F..T].имя ? (group (имя) (repeat F T (var () слово)))

// ===== Ссылки =====
// @.имя ? (lnk имя)
// {@ | слово}.имя {::слово}[inf].путь ? (lnk имя @.путь)

// ===== Данные =====
// целое ? (int целое)
// вещ-е ? (real вещ-е)
// слово ? (word слово)
// «литеры» ? (word литеры)
// '~~~' ? (text ~~~)

// ===== Скобки =====
// (~~~) ? (B ~~~)
// <слово ~~~> ? (exec (слово) ~~~)


Template FunctionName ::= word.fname ; ///todo: словность?
Template TemplateName ::= word.fname ; ///todo: словность?




P2_Builder0  { e.e = <Prout '<P2_Builder ' e.e '>'> <P2_Builder0 e.e>; }
P2_Builder {

   { MODULE | LEFT_PART | OBRAZEC } = ;

   // шаблон  /// todo: проверку на словность имени
   MODULE "Template" {"$separator" |} TemplateName.tname {"$separator" |} "::=" e.leftPart "$;" END.next
	   =	( "template" @.tname <P2_Builder  "LEFT_PART"  @.leftPart> ) 
		<P2_Builder  "MODULE"  @.next> ;
   // функция
   MODULE  FunctionName.fname {"$separator" |} ("{ " END.block ) {"$separator"|} { "$;" |} END.next
	   =	( "func" @.fname  <P2_Builder  BLOCK  @.block> )
		<P2_Builder  MODULE  @.next> ;

   ///  todo блоком
   LEFT_PART e.obr "$," END.if	=	("left-part" <P2_Builder  OBRAZEC @.obr> <P2_Builder  CONDITION @.if>);
   LEFT_PART e.obr  =	("left-part" <P2_Builder  OBRAZEC @.obr>);

   CONDITION e.cond1   "$," END.condN = <P2_Builder  CONDITION @.cond1> <P2_Builder  CONDITION @.condN>;
   CONDITION e.obrazec "$:" e.result  = ("if" <P2_Builder  RIGHT_PART @.obrazec> ("left-part" <P2_Builder  OBRAZEC @.result>));

   BLOCK   e.predl "$;" END.next    =    <P2_Builder  SENTENCE @.predl>  <P2_Builder  BLOCK @.next> ;
   BLOCK  {"$separator" |} = ; // пропускает когда блок пуст!
   BLOCK   END.predl    =    <P2_Builder  SENTENCE @.predl>;
   //SENTENCE e.left "$=" e.rigth  =  ();
   
   SENTENCE e.leftpart "$=" END.rightpart = ("sentence" <P2_Builder  LEFT_PART @.leftpart><P2_Builder  RIGHT_PART @.rightpart>);

// ===== Переменные =====
   OBRAZEC  ("word" e.word)"$." ("word" e.name) END.next	= 	(var (e.name) e.word) <P2_Builder  OBRAZEC @.next>;
   OBRAZEC  ("{ " e.chain) "$." ("word" e.name) END.next	=	(group (@.name) <P2_Builder OBRAZEC @.chain>) <P2_Builder  OBRAZEC @.next>;
   OBRAZEC  ("{ " e.chain)("[ " e.from ".." e.to) "$." ("word" e.name)  END.next	
								=	(group (@.name) (repeat (@.from) (@.to) <P2_Builder OBRAZEC @.chain>)) <P2_Builder  OBRAZEC @.next>;
   OBRAZEC  ("word" e.word)("[ " e.from ".." e.to) "$." ("word" e.name)  END.next
								=	(group (@.name) (repeat (@.from) (@.to) (var () @.word))) <P2_Builder  OBRAZEC @.next>;

// ===== Ссылки =====
   OBRAZEC "$@" "$." ("word" e.name) END.next	= 	 (lnk @.name) <P2_Builder  OBRAZEC @.next>;
   OBRAZEC {"$@" | ("word" e.)} "$." ("word" e.name) { "::" ("word" e.) }[inf].path END.next	= 	 (lnk @.name @.path) <P2_Builder  OBRAZEC @.next>;

// ===== Данные =====
   OBRAZEC целое ? (int целое) <P2_Builder  OBRAZEC @.next>;
   OBRAZEC вещ-е ? (real вещ-е) <P2_Builder  OBRAZEC @.next>;
   OBRAZEC слово ? (word слово) <P2_Builder  OBRAZEC @.next>;
   OBRAZEC «литеры» ? (word литеры) <P2_Builder  OBRAZEC @.next>;
   OBRAZEC '~~~' ? (text ~~~) <P2_Builder  OBRAZEC @.next>;

// ===== Скобки =====
   OBRAZEC (~~~) ? (B ~~~) <P2_Builder  OBRAZEC @.next>;
   OBRAZEC <слово ~~~> ? (exec (слово) ~~~) <P2_Builder  OBRAZEC @.next>;
   
   
   RIGHT_PART e. = right_part;

   word.state "$separator" END.next   =	<P2_Builder @.state @.next>;	   
   word.state word.t       END.next, 
	   <Explode word.t> : '$line:' Digits.
	   =	@.t <P2_Builder @.state @.next>;


   // Обработка ошибок 
   MODULE e.text word.ln e. ,
	   <Explode word.ln> : '$line:' Digits.line
		   =  <DoError <Numb @.line> ' temlpate or function defenition expected here: `' e.text '`'>;


   word.state  e.text word.ln e. ,
	   <Explode word.ln> : '$line:' Digits.line
		   =  <DoError <Numb @.line> word.state '-item expected here: `' e.text '`'>;
}







//   3.      семантический анализ и оптимизация (перестройка структуры программы)
//   4.      построение байт/xml-кода



// почее
PostScan {
	word.A END.next,
		<Explode word.A> : '$line:' END. = <PostScan @.next>;
	 
	(END.A) END.next = (<PostScan @.A>) <PostScan @.next>;
	
	t.A  END.next = @.A <PostScan @.next>;
	=;
}
