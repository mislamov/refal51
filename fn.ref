// **********************************************
InputFile{='fn.ref';}

$Entry Go { = <Prout <P1_Builder <P1_Prescaning ()<P1_Prescaning_pre 0 '\n'<Mount <InputFile>>'\n' >>>>; }


Template comment  ::= { '/*' e. '*/' | '//' e. '\n' } ! ;
Template Digit ::= { '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '0' };
Template Digits	  ::= Digit. { Digits. | } ! ;
Template Letter	  ::= { 'z'|'x'|'c'|'v'|'b'|'n'|'m'|'a'|'s'|'d'|'f'|'g'|'h'|'j'|'k'|'l'|'q'|'w'|'e'|'r'|'t'|'y'|'u'|'i'|'o'|'p'|
			'Z'|'X'|'C'|'V'|'B'|'N'|'M'|'A'|'S'|'D'|'F'|'G'|'H'|'J'|'K'|'L'|'Q'|'W'|'E'|'R'|'T'|'Y'|'U'|'I'|'O'|'P'| '-' | '_' 
			};


DoError { int.line END.text = <Print '#### ERROR ['@.line']: ' @.text>; }

// счет строк для сообщений об ошбках
P1_Prescaning_pre {
	int.line  e.pred '\n' END.next,
		<+ 1 int.line> : int.newline 
		=	@.pred  '\n'<Implode '$line:' @.newline> <P1_Prescaning_pre @.newline @.next>;
	int.line  END.next =  @.next <Implode '$line:' <+ 1 @.line>>;
}


Template separate  ::= { ' ' | '\t' | comment. | '\r' | '\n' | '$Entry' };
Template separateS ::= separate. { separateS. | } ! ;


/////////////////////////////////////////////////////////////
//   1.      prescaning-парсинг (чтение знаков языка)
/////////////////////////////////////////////////////////////
OtherBrack { '>'='<';'}'='{';']'='[';')'='('; }
ImplodeMeta { ';'="$;";  e.e=<Implode e.e>; }
ImplodeMeta { ';'="$;";  e.e=<Implode e.e>; }
P1_Prescaning0 { END.e = <Prout 'P1_Prescaning: [' @.e ']'><P1_Prescaning0 @.e>; }
P1_Prescaning {
	(E.code) separateS. END.next  
					=   <P1_Prescaning  (E.code "$separator") @.next>;
					
	(E.code) 
	{';'|'...'|'..'|'.'|'::='|'::'|':'|'='|'|'|'!'|'@'|','
	 |'+'|'-'|'*'|'/'
	 | '$NOT' | '$not'
	}.item  END.next 
					=  <P1_Prescaning  (E.code <ImplodeMeta @.item>) @.next>;
					
	(E.code) Digits.num  END.next  
					=  <P1_Prescaning  (E.code <Numb @.num>) @.next>; /// todo: вещественные в разных форматах
	(E.code) { Letter. e. }.word { s.notletter END.nn }.next,
		$NOT s.notletter : Letter. ,
		$NOT s.notletter : Digit.
					=   <P1_Prescaning  (E.code <Implode @.word>) @.next>;
					
	(E.code) '\'' e.all,
		<P1_Prescaning_quote ('\'') e.all> : (e.text) END.next
					=  <P1_Prescaning  (E.code ("text" e.text)) @.next>;

	(E.code) '"'  e.all,
		<P1_Prescaning_quote ( '"') e.all> : (e.text) END.next
					=  <P1_Prescaning  (E.code ("word" e.text)) @.next>;

	// начало скобочного выражения
	(E.code) {'{'|'['|'('|'<'}.br  END.next
					=  <P1_Prescaning  (E.code <Implode @.br' '>) @.next>;
	// конец скобочного выражения
	(E.code) {'}'|']'|')'|'>'}.br  END.next,
		<Implode <OtherBrack @.br>' '> : s.obr,
		@.code : E.A  s.obr  END.B
					=  <P1_Prescaning  (@.A (s.obr @.B)) @.next>;

	// проброс метакодов
	(E.code) word.l END.next,
		<Explode @.l> : '$' e.e 
					=  <P1_Prescaning  (E.code @.l) @.next>;
	
	(E.code) t.unknown e.text word.linelable END.next,
		<Explode  word.linelable>: '$line:' Digits.line
					=  <DoError <Numb @.line> 'Unexpected item `' @.unknown '` here : ' @.unknown @.text>;

	(E.code)  =  E.code; 
}

P1_Prescaning_quote {
	(t.qu E.text) t.qu END.next = (@.text) @.next;
	(t.qu E.text) '\\' s.metas END.next = <P1_Prescaning_quote (@.qu @.text <Unescape @.metas>) @.next>;
	(t.qu E.text) s.sym END.next = <P1_Prescaning_quote (@.qu @.text @.sym) @.next>;
	(t.qu E.text) t.s e.else1  word.linelable  END.else2,
		<Explode  word.linelable>: '$line:' Digits.line
		=	<DoError <Numb @.line> 'Unecpected text-symbol `'@.s'` here: ' @.s @.else1>;
	(t.qu E.text) END.else
		=	<DoError 0 'Unecpected text-symbol here: ' @.else>;
	END.e = <DoError 0 '<P1_Prescaning_quote  ' @.e ' > - ???'>;
}

Unescape {
	'\'' = '\'';
	'"' = '"';
	'n' = '\n';
	't' = '\t';
	'r' = '\r';
	'\\' = '\\';
}

//////////////////////////////////////////////////////////////////////////////////////////////
//   2.      структуризация и синтаксический анализ (генерация структуры программы)
//////////////////////////////////////////////////////////////////////////////////////////////

// ===== Переменные =====
// слово.имя ? (var (имя) слово)
// {цепь}.имя ? (group (имя) <S цепь>)
// {цепь}[F..T].имя ? (group (имя) (repeat F T <S цепь>))
// слово[F..T].имя ? (group (имя) (repeat F T (var () слово)))

// ===== Ссылки =====
// @.имя ? (lnk имя)
// {@ | слово}.имя {::слово}[inf].путь ? (lnk имя @.путь)

// ===== Данные =====
// целое ? (int целое)
// вещ-е ? (real вещ-е)
// слово ? (word слово)
// «литеры» ? (word литеры)
// '~~~' ? (text ~~~)

// ===== Скобки =====
// (~~~) ? (B ~~~)
// <слово ~~~> ? (exec (слово) ~~~)


Template FunctionName ::= word.fname ; ///todo: словность?
Template TemplateName ::= word.fname ; ///todo: словность?


P1_Builder {

   // шаблон  /// todo: проверку на словность имени
   MODULE "Template" {"$separator" |} TemplateName.tname {"$separator" |} "::=" e.leftPart "$;" END.next
	   =	( "template" @.tname <P1_Builder  "LEFT_PART"  @.leftPart> ) 
		<P1_Builder  "MODULE"  @.next> ;

   // функция
   MODULE  FunctionName.fname {"$separator" |} ("{ " END.block ) {"$separator"|} { "$;" |} END.next
	   =	( "func" @.fname  <P1_Builder  BLOCK  @.block> )
		<P1_Builder  MODULE  @.next> ;

   LEFT_PART = leftpart;
   BLOCK = block;


   word.state word.t END.next, 
	   <Explode word.t> : {'$separator'|} { '$line:' Digits. |}.lne 
	   =	@.lne <P1_Builder @.state @.next>;

}







//   3.      семантический анализ и оптимизация (перестройка структуры программы)
//   4.      построение байт/xml-кода
