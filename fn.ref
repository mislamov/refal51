
$ENTRY Go {
	//,<Mount 'direfal_scaner.ref_'> : E.code
	,<Mount 'tt.ref'> : E.code
	=
		<Prout <MODULE <RefalTokens @.code>> >;
}


MODULE {
	(comment END.) E.next = <MODULE @.next>;
	{ "$" (word ENTRY) ' ' | } (word t.name) {' '|} ("{" e.body)  E.next 
				=				'<FUNCTION name="' <Explode @.name> '">' <Print <BLOCK @.body>> '</FUNCTION>\n' <MODULE @.next>;
	(word Template) ":" ":" "=" e.body ";" E.next = '<TEMPLATE name="' <Explode @.name> '">' <LEFT_PART @.body> '</TEMPLATE>\n' <MODULE @.next>;

	' ' E.next = <MODULE @.next>;
	";" E.next = <MODULE @.next>;
	=;
	e.else = <Prout 'Function or Template expected here: [' @.else ']'>;
}


BLOCK {
	' ' E.next = <BLOCK @.next>;
	(comment E.text) E.next = <BLOCK @.next>;
	e.sentence ";" E.next = '\n\t<SENTENCE>'<SENTENCE @.sentence>'</SENTENCE>'<BLOCK @.next>;
	=;
	E.else = '<SENTENCE>'<SENTENCE @.else>'</SENTENCE>'; // для блоков без ; в конце
//			<Error ('Bad sentence in block') @.else>;
}



SENTENCE {	
	e.left_part "=" E.rexpr,
		<ScanLeftPart  <ObjStream @.left_part>> : (E.left_part_code)(E.left_part_compiledata_stream),
		<ScanRightPart (@.left_part_compiledata_stream)(<ObjStream  @.rexpr>)> : E.right_part_code
		//<ProutDebug '['@.left_part']['@.rexpr']'>:
			=	
				'<LEFT-PART>'@.left_part_code'</LEFT-PART>'
				'<RIGHT-PART>'@.right_part_code'</RIGHT-PART>';

	//END.all,
	//@.all : 
	E.left_part "," e.rexpr ":" {' '|} ("{" E.block) {' '|},   // E.left_part - жадная чтобы захватить все условия
	<Prout @.left_part "," @.rexpr ":"  ("{" @.block) > : ,
		<RandFuncName> : word.fname,
		<ScanLeftPart  <ObjStream @.left_part>> : (E.left_part_code)(E.left_part_compiledata_stream),
		<ScanRightPart (@.left_part_compiledata_stream)(<ObjStream  ("<" (word @.fname) @.rexpr)>)> : E.right_part_code
			=	
				'\n\t\t<FUNCTION name="' <Explode @.fname> '">' <Print <BLOCK @.block>> '\n\t\t</FUNCTION>\n'
				'<LEFT-PART>'  @.left_part_code  '</LEFT-PART>'
				'<RIGHT-PART>' @.right_part_code '</RIGHT-PART>';

	{' '|} (comment E.text) {' '|} = ;
	E.else		=	<Error ('Bad sentence') @.else>;
}


// ищет ошибки в left-part. Возвращает код left-part и информацию для обработки right-part
// left-part ->  (left-part-code)(left-part-compiledata-stream)
ScanLeftPart {
	e.e = (<UnMeta e.e>)(e.e);
}


// ищет ошибки в right-part, используя инфу из left-part
// (left-part-compiledata-stream)(right-part) -> right-part-code
ScanRightPart{
	(e.1)(e.2) = (<UnMeta e.2>);
}

ObjStream {
	e.e = e.e;
}


Substr {
	{ 0 E.e | int.i } = ;
	// int.count E.text,  @E.text : s[@.count].str E.nexttext = @.str;
	int.i t.s E.e = @.s <Substr <- @.i 1> @.e>;
}

Error {
	(e.text) e.code,
		<Substr 128 <UnMeta @.code>> : E.cd
		=
		<ProutDebug @.cd >
		'\n\n<ERROR>\n' e.text': ' @.cd '\n\n ' @.code ' \n</ERROR>\n\n';
	//E.else = <Prout 'ERROR of ERRORs! ' E.else>;
}


UnMeta  {
	E.e = <UnMeta_post <UnMeta_pre @.e>>;
}

UnMeta_post {
	e.1 ' . ' E.2 = e.1'.'<UnMeta_post E.2>;
	E.e = @.e;
}

UnMeta_pre {
	("(" e.val) E.e   = '('<UnMeta_pre e.val> ') '<UnMeta_pre @.e>;
	("{" e.val) E.e   = '{'<UnMeta_pre e.val>'}'  <UnMeta_pre @.e>;
	("[" e.val) E.e   = '['<UnMeta_pre e.val>']'  <UnMeta_pre @.e>;
	("<" e.val) E.e   = '<'<UnMeta_pre e.val>'> ' <UnMeta_pre @.e>;
	(text e.val)E.e   = '\''<UnMeta_pre e.val>'\' ' <UnMeta_pre @.e>;
	(word.class e.val) E.e	= <UnMeta_pre <ExplodeAll @.val> @.e>;
	s.sym E.e         	= <ExplodeAll @.sym> <UnMeta_pre @.e>;
	(t.s) E.e         	= <UnMeta_pre @.s @.e>;
	E.e 			= @.e;
}

RandFuncName {
	= "$RandomFuncName";
}
