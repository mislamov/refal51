
Template theword ::= (word e.value);
Template theint   ::= (int e.value);

Template varname ::= { theword. | theint. } ;


Template FUNCTION ::= 
	{"$"(word ENTRY)' '|}  
	(word t.name) {' '|} ("{" BLOCK.body) {' '|};

Template TEMPLATE ::=
	(word Template) ' ' (word t.name) {' '|} ":" ":" "=" LEFT_PART.body ;

Template BLOCK ::= SENTENCE.head ";" {' '|} { BLOCK. |}.tail ;
Template SENTENCE   ::=  { LEFT_PART. | }.left_part "=" { RIGHT_PART. | }.right_part ;

Template LEFT_PART  ::=  L_PATTERN.pattern { IFs. |}.conditions ;
Template RIGHT_PART ::=  R_PATTERN.pattern ;
		//$NOT @.pattern : e. (~( e. VAR. E. )~) E.
		//<SELECT_ALLVAR PATTERN.pattern> : $empty ;   // упростиь, когда появятся сканирующие скобки, или апостраф баша

Template IFs ::= "," IF.head {IFs.|}.tail;
Template IF  ::= RIGHT_PART.right_part ":" L_PATTERN.left_part;


Template L_PATTERN ::= { {}.p | L_PATTERN_nonemp.p } ;
Template R_PATTERN ::= { {}.p | R_PATTERN_nonemp.p } ;

Template L_PATTERN_nonemp ::=
	L_ITEM.head {L_PATTERN_nonemp.tail | {}.tail } ;
Template R_PATTERN_nonemp ::=
	R_ITEM.head {R_PATTERN_nonemp.tail | {}.tail } ;

Template L_ITEM ::=
	{ ' '| ("(" L_PATTERN. ) | VAR. | LNK. | SYMBOL. } ;

Template R_ITEM ::=
	{ ' '| ("(" RIGHT_PART. ) | ("<" R_PATTERN_nonemp. ) | VAR. | LNK. | SYMBOL. } ;

Template SYMBOL ::=
	{ theword. | (int e.) | (real e.) | (text e.) | "$" (word empty) } ;


Template VAR    ::= {
	theword.type1  	       SPECIFICATORS.s1  "." { varname. | }.name1 |
	GROUP_OR_VARIANT.type2  SPECIFICATORS.s2  { "." varname. | }.name2  
};
					

Template LNK    ::=  { {  "@"{theword.|} | "&"{theword.|} | theword. }.type "." varname.name }.thevar  VAR_PATH.path ;   // использование @ обязательно!
Template VAR_PATH ::= { ":" ":" varname. VAR_PATH. | $empty } ;

Template GROUP_OR_VARIANT ::= ("{" e.) ; //todo: уточнить

Template SPECIFICATORS ::= { { REPEATER. }.head SPECIFICATORS.tail |} ;
Template REPEATER ::= ("[" e.); // todo: уточнить


SELECT_ALLVAR {
	( E.a ) E.b = <SELECT_ALLVAR @.a>     <SELECT_ALLVAR @.b>;
	VAR.v   E.b = &VAR.v 		      <SELECT_ALLVAR @.b>;
	//&.point E.b = <SELECT_ALLVAR @.point> <SELECT_ALLVAR @.b>;
	s.1 E.b = <SELECT_ALLVAR @.b>;
	$empty = $empty;
};


PROGRAM {
	FUNCTION.f  {";" |} E.next = <Prout 'Function: ' @.f::name> &FUNCTION.f <PROGRAM @.next>;
	TEMPLATE.tm  ";" E.next = <Prout 'Template: ' @.tm::name> &TEMPLATE.tm <PROGRAM @.next>;
	' ' e.e = <PROGRAM e.e>;
	=;
	// ОШИБКИ
	e.1 TEMPLATE.tm  ";" E.next = <PROGRAM e.1> &TEMPLATE.tm <PROGRAM @.next>;;
	e.1 FUNCTION.f   {";"|}  E.next = <PROGRAM e.1> &FUNCTION.f <PROGRAM @.next>;;
	e.else = 'no: ' e.else;
}

// Семантический анализ
SEMANTIC {
	&FUNCTION.f e.next = '<FUNCTION name="' @.f::name '">' <Sentences &FUNCTION.f::body> '</FUNCTION>\n' <SEMANTIC e.next>;
	&TEMPLATE.t e.next = '<TEMPLATE name="' @.t::name '"><LEFT-PART>' <LeftPart_XML <LeftPart_SEMANTIC <PatternToPoints &TEMPLATE.t::body::pattern> &TEMPLATE.t::body::conditions>> '</LEFT-PART></TEMPLATE>\n'<SEMANTIC e.next>;
	=;
}

LeftPart_SEMANTIC {
	E.patt &IFs.conds,
		<NormizeVariables () E.patt> : (E.vars) E.patt_var,
		<IFs_SEMANTIC (E.vars) &IFs.conds>
		= E.patt_var;

	E.patt,
		<NormizeVariables () E.patt> : (E.vars) E.patt_var
		= E.patt_var;	
}

//		<NormizeVariables (E.vars_begin) E.patt> : (E.vars) E.patt_var,
//		E.vars_begin - ранее открытые переменные
//       E.vars - теперь открытые переменные
//		E.patt_var - ОВ E.patt, в котором по факту закрытые переменные переведены в ссылки
NormizeVariables {
//	(E.vars_begin) E.patt = (E.vars_begin) E.patt ;
	(E.vars_begin) E.patt = (E.vars_begin) E.patt ;
}

PatternToPoints {
	{ &L_PATTERN.x |  &R_PATTERN.x |  {$empty}.x }, @.x : $empty = ; 
	&.pattern = &.pattern::p::head <PatternToPoints &.pattern::p::tail>;
}
	
Sentences {
	e.e=e.e;
}

Go {
	= <Prout 
		<SEMANTIC <PROGRAM
			<Prout 'Delete comments...'>
			<DelComments <RefalTokens <Mount 'f.ref'>>>
			<Prout 'done'>
		>>
	>;
}

DelComments_ {
	e.e = <Prout 'del: 'e.e><DelComments_ e.e>;
}
DelComments {
	{' '|} (comment e.comm) {' '|} e.e = <DelComments ' ' e.e>;
	( {"("|"{"|"["|"<"}.sig  e.1 ) e.e = (@.sig <DelComments e.1>) <DelComments e.e>;
	t.1 e.e = @.1 <DelComments e.e>;
	=;
}

PProut {
	(text e.e) e.next = "'" e.e "'" <PProut e.next>;
	( {int|word|real} e.e ) e.next = e.e <PProut e.next>;
	{' '|"."|"|"}.sym   e.next = @.sym <PProut e.next>;
	=;
	e.else = <Prout 'error: [' e.else ']'>;
}


F {
	 e.e = ; 
}
