Repeat {
	t.fname e.arg While (e.exp),
	<Mu t.fname e.arg> : {
		e.all e.exp = e.all '\n';
		e.else = e.else '\n' <Repeat t.fname e.arg While (e.exp)>;
	};

	e.else = <PPrint "@ERROR:" ('in Repeat: ' e.else)>;
}

Mount {
	e.fname = <Open 'r' 9 e.fname>'\n'<Repeat Get 9 While (0)>
}

ImplNumb {
	e.all,
		e.all : e.num e.notnum,
		<Numb e.all> : t.tnum,
		<Symb t.tnum> : e.num = t.tnum e.notnum;
	e.e = 0 e.e;
}

**********************************************************
*
* Разбор элементов языка
*
**********************************************************

ScanModule_ { e.e = <PProut "\nScanModule: " e.e/*<DeScob e.e>*/><ScanModule_ e.e>; }
ScanModule {
	=;


	/* подразумевается, что обрабатывается только один внешний блок */
	(t.fname) ('{') e.bodyPredl ('}') /*e.modulenext*/,
	<ScanPredlsInBody e.bodyPredl>   : e.bodyScaned,
	<ExistError e.bodyScaned> : {
		false	=	"<FUNCTION name=\"" t.fname "\">" e.bodyScaned "</FUNCTION>\n" /*<ScanModule e.modulenext>*/ ;
		true 	= 	<MakeError ScanModule e.bodyScaned>;
		};

	

	('$') ( e.entry ) e.else,
		<Upper <Explode e.entry>> : 'ENTRY' = <ScanModule e.else>;

	e.error = <MakeError ScanModule e.error>;
}

ScanPredlsInBody_  { e.e = <PProut "\nScanPredlsInBody: " <DeScob e.e>><ScanPredlsInBody_ e.e>; }
ScanPredlsInBody {
	e.predl (';') e.nextBodyPredl,
	<ScanPredl e.predl>	: e.pscaned,
	<ExistError e.pscaned>	: false,
	e.nextBodyPredl : {
					=	"<SENTENCE>" e.pscaned "</SENTENCE>";
				e.e	=	"<SENTENCE>" e.pscaned "</SENTENCE>" <ScanPredlsInBody e.e>;
	};

	e.predl t.last, 
		t.last : {
			(';')   = "<SENTENCE>" <ScanPredl  e.predl> "</SENTENCE>";
			t.last  = "<SENTENCE>" <ScanPredl  e.predl t.last> "</SENTENCE>";
		};

	= <MakeError ScanPredlsInBody  'can\'t be empty body of block'>;
}



ScanPredl_ { e.e = <PProut "\nScanPredl: " <DeScob e.e>><ScanPredl_ e.e>; }
ScanPredl  {
	/* блок - недоработанная заглушка. создает вызов не существуюущей функции */
	e.left-part (',') e.RIGHT-PART (':') ('{') e.block ('}'),

	<ScanRigthPart e.RIGHT-PART> : e.rpscaned,
	<ExistError e.rpscaned> : false,

	<ScanLeftPart e.left-part> : e.lpscaned,
	<ExistError e.lpscaned> : false,

	<ScanPredlsInBody e.block> : e.bscaned,
	<ExistError e.bscaned> : false,

	<GetRand> : t.rand,
	<Explode t.rand> : e.randtext,
	<ScanIfs (',') e.RIGHT-PART (':') (e)('.')(t.rand)> : e.lp

	=	"<LEFT-PART>"  e.lpscaned  e.lp  "</LEFT-PART>"
		"<RIGHT-PART>" <ScanRigthPart  ('<')(t.rand)(e)('.')(t.rand)('>')> "</RIGHT-PART>";


	e.leftpart ('=') e.rigthpart,
	<ScanLeftPart  e.leftpart>  : e.leftScanned,
	<ExistError e.leftScanned> : {
		true  = <MakeError ScanPredl e.leftScanned>;

		false,
		<ScanRigthPart e.rigthpart> : e.rigthScanned,
		<ExistError e.rigthScanned> : {
			false	=
				"<LEFT-PART>"  e.leftScanned  "</LEFT-PART>"
				"<RIGHT-PART>" e.rigthScanned "</RIGHT-PART>";
			true	=
				<MakeError ScanPredl e.rigthScanned>;
			};
	};

	e.error = <MakeError ScanPredl e.error>;

}
ScanLeftPart_ { e.e = <PProut "\nScanLeftPart: " <DeScob e.e>><ScanLeftPart_ e.e>; }
ScanLeftPart {
	=;

	e.shablon (',') e.ifs =
			<ScanObjectExprWithoutExecs e.shablon>
			<ScanIfs (',') e.ifs>;
	e.shablon = <ScanObjectExprWithoutExecs e.shablon>;
/*	e.error = <MakeError ScanLeftPart e.error>;*/
}



ScanRigthPart_ { e.e = <PProut "\nScanRigthPart: " <DeScob e.e>><PProut "\nScanRigthPart: " e.e><ScanRigthPart_ e.e>; }
ScanRigthPart {
	e.rp = <ScanObjectExprWithExecs  e.rp>;
}



ScanObjectExprWithoutExecs_ { e.e = <PProut "\nScanObjectExprWithoutExecs: " e.e><ScanObjectExprWithoutExecs_ e.e>; }
ScanObjectExprWithoutExecs {
	e.arg, 
		<ScanObjectExprWithoutExecsFirst e.arg> : e.arg_I,
		<ExistError e.arg_I> : { 
			false	=	<TransformSpecificatorsInObjectExprWithoutExecs e.arg_I>;
			true	=	e.arg_I;
		};
}

IsVarName {
	e.name,
	<Type e.name> : {
		'L' s.sub s.1 e.2 = <IsVarName e.2>;
		'D' s.sub s.1 e.2 = <IsVarName e.2>;
		'*' e.e = true;
		e.else = false;
	};
}

/* перестраивает спецификаторы для загрузки программы: 
	варианты:	  {o   | => o   | => o   | => x   ? }
*/
TransformSpecificatorsInObjectExprWithoutExecs_ { e.e = <Prout "TransformSpecificatorsInObjectExprWithoutExecs:" e.e><TransformSpecificatorsInObjectExprWithoutExecs e.e>; };
TransformSpecificatorsInObjectExprWithoutExecs {
	e.all,
	e.all : e.1 "<GROUP_F name=\"" e.gname "\">" e.2 "</GROUP_F>" e.3,
		<NotHas "</GROUP_F>" e.2> : true,
		<NotHas "<GROUP_F name=\"" e.2> : true,
		<IsVarName e.gname> : true,
		e.2 : e.4 "|" e.5  
		=  	<TransformSpecificatorsInObjectExprWithoutExecs   
				e.1 
				"<GROUP name=\"" 
				e.gname 
				"\">" 
				"<VARIANTS>" 
				<ReplaceAll ("|") by ("<THE-VARIANT/>") in (e.2)> 
				"</VARIANTS>" 
				"</GROUP>" 
				e.3 
			>;

	e.all,
	e.all : e.1 "<GROUP_F name=\"" e.gname "\">" e.2 "</GROUP_F>" e.3,
		<NotHas "</GROUP_F>" e.2> : true,
		<NotHas "<GROUP_F name=\"" e.2> : true
		=	<TransformSpecificatorsInObjectExprWithoutExecs   e.1 "<GROUP name=\"" e.gname "\">" e.2 "</GROUP>" e.3 >;

	e.noOldGroups = e.noOldGroups;
}

ScanObjectExprWithoutExecsFirst {
	e.1 ('<') e.2 = <MakeError ScanObjectExprWithoutExecs 'unecpected "<" in <' e.2>;
	e.1 ('>') e.2 = <MakeError ScanObjectExprWithoutExecs 'unecpected ">" in >' e.2>;
	e.e = <ScanObjectExprWithExecs e.e>; /* уже знаем, что нету вызовов */
}

ReplaceAll {
	(e.old) by (e.new) in (e.arg),
		e.arg : e.1 e.old e.2 = e.1 e.new <ReplaceAll  (e.old) by (e.new) in (e.2)>;
		
	(e.old) by (e.new) in (e.arg) = e.arg;
}

NotHas {
	t.A e.1 t.A e.2 = false;
	e.e = true;
}

IsWordNumbDot {
	('.') = true;
	(t.word),
		<Type t.word> : {
				'Wi' t.word = true;
				'N0' t.word = true;
				e.e = false;
			};

	/*"$separator" = false;*/
	t.else = false;
}

ScanObjectExprWithExecs_ { e.e = <PProut "\nScanObjectExprWithExecs: " e.e><ScanObjectExprWithExecs_ e.e>; }
ScanObjectExprWithExecs {
	=;

	"$separator"	e.e = 	<ScanObjectExprWithExecs e.e>;
	"$not"		e.e = 	"<NOT/>"  <ScanObjectExprWithExecs e.e>;
	
	/* отсечение */
	('!')  e.e = "<CUTTER/>" <ScanObjectExprWithExecs e.e>;

	/* разделитель вариантов */
	('|')  e.e = "|" <ScanObjectExprWithExecs e.e>;

	/* групповые скобки c именем */
	('{')  e.oexp  ('}')('.')(t.varname) e.e,
		<ScanObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false,
		<Type t.varname> : {
			'W' s.sub t.varname = "<GROUP_F name=\"" <Explode t.varname> "\">" e.oexp_I "</GROUP_F>" <ScanObjectExprWithExecs e.e>;
			'N' s.sub t.varname = "<GROUP_F name=\"" <Symb t.varname>    "\">" e.oexp_I "</GROUP_F>" <ScanObjectExprWithExecs e.e>;
			e.else = <MakeError ScanObjectExprWithExecs 'bad varname for GROUP-brackets'>;
		};

	/* ВАРИАНТЫ */
	('{')  e.oexp  ('}')"["(e.from)".."(e.to)"]"('.')(t.varname) e.e,
		<ScanObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname "\">" 
		"<REPEAT from=\"" e.from "\" to=\"" e.to "\">" 
			"<GROUP_F name=\""  <GetRandomName> "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ScanObjectExprWithExecs e.e>;

	('{')  e.oexp  ('}')"["(e.from)"..." "]" ('.')(t.varname) e.e,
		<ScanObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname "\">" 
		"<REPEAT from=\"" e.from "\" to=\"inf\">" 
			"<GROUP_F name=\""  <GetRandomName> "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ScanObjectExprWithExecs e.e>;

	('{')  e.oexp  ('}')"[" "..."(e.to)"]" ('.')(t.varname) e.e,
		<ScanObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname "\">" 
		"<REPEAT from=\"0\" to=\""e.to"\">" 
			"<GROUP_F name=\"" <GetRandomName>  "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ScanObjectExprWithExecs e.e>;

	('{')  e.oexp  ('}')"[" (e.fromto)"]" ('.')(t.varname) e.e,
		<ScanObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname  "\">" 
		"<REPEAT from=\""e.fromto"\" to=\""e.fromto"\">" 
			"<GROUP_F name=\"" <GetRandomName>  "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ScanObjectExprWithExecs e.e>;



	/* групповые скобки без имени */
	('{')  e.oexp  ('}') e.e,
		<ScanObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\""  <GetRandomName>  "\">" e.oexp_I "</GROUP_F>" <ScanObjectExprWithExecs e.e>;

		
	
	

	/* Скобки */
	('(') e.inside (')') e.next,
	<ScanObjectExprWithExecs e.inside> : e.insidescaned_I,
	<ExistError  e.insidescaned_I> : false
	=	"<BRACKET>"  e.insidescaned_I "</BRACKET>" <ScanObjectExprWithExecs  e.next >;

	('<') (t.word) e.inside ('>') e.next,
	<ScanObjectExprWithExecs e.inside> : e.insidescaned_I,
	<ExistError  e.insidescaned_I> : false

	=	"<EXEC>" "<WORD>" t.word "</WORD>"  e.insidescaned_I "</EXEC>" <ScanObjectExprWithExecs e.next>;




	/* продолжение ссылки напеременную */
	"$path" ('/')(t.1) e.next, 
		<Type t.1> : 'W' s.sub1 t.1
		=	'/' <Explode t.1> <ScanObjectExprWithExecs  "$path" e.next>;

	/* конец ссылки напеременную */
	"$path" e.next		
		=	"</LNK>" <ScanObjectExprWithExecs  e.next>;



	/*ссылка на переменную*/
	(t.1)('.')(t.2)('/') e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'W' s.sub2 t.2
	=	"<LNK>" <Explode t.2>
		<ScanObjectExprWithExecs "$path" ('/') e.next>;

	/*ссылка на переменную c числовым именем*/
	(t.1)('.')(t.2)('/') e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'N' s.sub2 t.2
	=	"<LNK>" <Symb t.2>
		<ScanObjectExprWithExecs "$path" ('/') e.next>;

	/*переменная*/
	(t.1)('.')(t.2) e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'W' s.sub2 t.2
	=	"<VAR>" <Explode t.1> '.' <Explode t.2> "</VAR>"
		<ScanObjectExprWithExecs e.next>;

	/*переменная с числовым именем*/
	(t.1)('.')(t.2) e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'N' s.sub2 t.2
	=	"<VAR>" <Explode t.1> '.' <Symb t.2> "</VAR>"
		<ScanObjectExprWithExecs e.next>;
	/**/

	/*переменная без имени*/
	(t.1)('.') "$separator" e.next,
	<Type t.1> : 'W' s.sub1 t.1
	=	"<VAR>" <Explode t.1> '.' "</VAR>"
		<ScanObjectExprWithExecs e.next>;
	/**/

	/* ссылка на переменную с НЕ числовым именем*/
	('@')('.')(t.2) e.next,
	<Type t.2> : 'W' s.sub2 t.2
	=	"<LNK>" <Explode t.2> "</LNK>"
		<ScanObjectExprWithExecs e.next>;
	/**/

	/* ссылка на переменную с числовым именем*/
	('@')('.')(t.2) e.next,
	<Type t.2> : 'N' s.sub2 t.2
	=	"<LNK>" <Symb t.2> "</LNK>"
		<ScanObjectExprWithExecs e.next>;
	/**/

	/*просто слово или число*/
	(t.1) e.next, <Type t.1> :
				{
					'N' s.sub t.1 = "<INT>" <Symb t.1> "</INT>"   <ScanObjectExprWithExecs e.next>;
					'W' s.sub t.1 = "<WORD>" <Explode t.1> "</WORD>" <ScanObjectExprWithExecs e.next>;
					s.T s.sub t.1 = "@ERROR:" ('unkonown symbol in object-expression = "' t.1 '" of type [' s.T s.sub '] in ' (t.1) e.next);
				};


	/*термальное предложение*/
	(e.1) e.next  =  "<WORD>" e.1 "</WORD>" <ScanObjectExprWithExecs e.next>;

	/* не возможно появления тут аргумента вида (t.1) e.2   !!! */

	s.s e.next = "<TEXT>" s.s "</TEXT>" <ScanObjectExprWithExecs e.next>;

	e.error = <MakeError ScanObjectExprWithExecs e.error>;

}


ScanIfs_ { e.e = <PProut "\nScanIfs: " e.e/*<DeScob e.e>*/><PProut "\nScanIfs: " <DeScob e.e>><ScanIfs_ e.e>; }
ScanIfs {
	=;

	/* несколько условий */
/*
	(',') e.RIGHT-PART (':') e.left-part (',') e.ifs,
	<ScanLeftPart e.left-part>   : e.lpscaned,
	<ExistError  e.lpscaned> : false,
	<ScanRigthPart e.RIGHT-PART> : e.rpscaned,
	<ExistError  e.rpscaned> : false,
	<ScanIfs (',') e.ifs> : e.ifscaned,
	<ExistError  e.ifscaned> : false
	=	"<IF>" "<RIGHT-PART>" e.rpscaned "</RIGHT-PART>" "<LEFT-PART>" e.lpscaned "</LEFT-PART>" "</IF>"
		e.ifscaned;
*/

	(',') e.RIGHT-PART (':') e.next,
	<ScanRigthPart e.RIGHT-PART> : e.rpscaned,
	<ExistError  e.rpscaned> e.next : {
		false e.left-part (',') e.ifs,
		<ScanLeftPart e.left-part>   : e.lpscaned,
		<ExistError  e.lpscaned> : {
				false, e.rpscaned : "<NOT/>" e.rpscanednext
				= 	"<IF not=\"true\">" "<RIGHT-PART>" e.rpscanednext "</RIGHT-PART>" "<LEFT-PART>" e.lpscaned "</LEFT-PART>" "</IF>"
					<ScanIfs (',') e.ifs>;
					
				false, e.lpscaned : "<NOT/>" e.lpscanednext
				= 	"<IF not=\"true\">" "<RIGHT-PART>" e.rpscaned "</RIGHT-PART>" "<LEFT-PART>" e.lpscanednext "</LEFT-PART>" "</IF>"
					<ScanIfs (',') e.ifs>;
					
				false
				= 	"<IF>" "<RIGHT-PART>" e.rpscaned "</RIGHT-PART>" "<LEFT-PART>" e.lpscaned "</LEFT-PART>" "</IF>"
					<ScanIfs (',') e.ifs>;
					
				true  = <MakeError ScanIfs e.lpscaned>;
		};

		false e.left-part,
		<ScanLeftPart e.left-part>   : e.lpscaned,
		<ExistError  e.lpscaned> : {
				false, e.rpscaned : "<NOT/>" e.rpscanednext 
				= 	"<IF not=\"true\">" "<RIGHT-PART>" e.rpscanednext "</RIGHT-PART>" "<LEFT-PART>" e.lpscaned "</LEFT-PART>" "</IF>";
				false, e.lpscaned : "<NOT/>" e.lpscanednext 
				= 	"<IF not=\"true\">" "<RIGHT-PART>" e.rpscaned "</RIGHT-PART>" "<LEFT-PART>" e.lpscanednext "</LEFT-PART>" "</IF>";
				false
				= 	"<IF>" "<RIGHT-PART>" e.rpscaned "</RIGHT-PART>" "<LEFT-PART>" e.lpscaned "</LEFT-PART>" "</IF>";
				true  
				=	<MakeError ScanIfs e.lpscaned>;
		};

		true  e.next	=   <MakeError ScanIfs e.rpscaned>;
	};

/*
	(',') e.RIGHT-PART (':') e.left-part (',') e.ifs,
	<ScanLeftPart e.left-part>   : e.lpscaned,
	<ExistError  e.lpscaned> : false,
	<ScanRigthPart e.RIGHT-PART> : e.rpscaned,
	<ExistError  e.rpscaned> : false
	=	"<IF>" "<RIGHT-PART>" e.rpscaned "</RIGHT-PART>" "<LEFT-PART>" e.lpscaned "</LEFT-PART>" "</IF>"
		<ScanIfs (',') e.ifs>;
*/

	/* одно условие */
/*	(',') e.RIGHT-PART (':') e.left-part,
	<ScanLeftPart e.left-part>	: e.lpscaned,
	<ExistError  e.lpscaned> 	: false,
	<ScanRigthPart e.RIGHT-PART>	: e.rpscaned,
	<ExistError  e.rpscaned>	: false
	=	"<IF>" "<RIGHT-PART>" e.rpscaned "</RIGHT-PART>" "<LEFT-PART>" e.lpscaned "</LEFT-PART>" "</IF>" ;
*/

	e.error = <MakeError ScanIfs e.error>;
}


************************
ExistError { e.1 "@ERROR:" (e.msg) e.2 = true; e.else = false; }
MakeError  {
	t.fname e.1 "@ERROR:" (e.msg) e.2 	= "@ERROR:" (e.msg);
	t.fname e.e 	= "@ERROR:" ('value unscaned by <'t.fname'> : 'e.e) ;
}
DeScob {
 (e.1) e.2 = e.1 <DeScob e.2>;
 s.1 e.e = s.1 <DeScob e.e>;
 =;
}






GetRand { ,<Rp rand'='<+ 1 <Cp rand>>>:e.e = <Implode 'rrrr98358935897389457'<Symb <Cp rand>>> ;  }


$ENTRY Go { 
	,<Br rand'='0>:,
	<Br scanbl'='0>:,
	<Preproc <FindAndUseBlock() <Scan <Mount <Arg 1> >>>> : e.program,
	<ExistError e.program> : false
	=
		<Open 'w' 3 <Arg 1>'.xml'>
		<Put 3 
			<DePlode "<BEGIN>"<Preproc <FindAndUseBlock() <Scan <Mount <Arg 1> >>>>"</BEGIN>">
		>;
		
		
	e.else = <Exit 9>;
}

/* переводит все термы в текст */
DePlode {
	=;
	s.1 e.e, <Type s.1>:'W'e.ee = <Explode s.1> <DePlode e.e>;
	t.1 e.e = t.1 <DePlode e.e>;
}


$ENTRY Go1 {
	=	<Br rand'='0><PProut <GetRand>><PProut <GetRand>><PProut <GetRand>><PProut <GetRand>>;
}


IsSeparatorChar {
	' '  = true;
	'\t' = true;
	'\n' = true;
	s.s = false;
}

Scan{
	=;
	'/*'  e.comm '*/' e.next  =  <Scan e.next>;
	'\n' '*' e.comm '\n' e.next  =  <Scan '\n' e.next>;


	s.1 '.' e.e,
		<IsSeparatorChar s.1> : true =	"$separator" ('.') <Scan e.e>;
	'.' s.1 e.e,
		<IsSeparatorChar s.1> : true =	('.') "$separator" <Scan e.e>;
	s.0 '.' s.1 e.e,
		<IsSeparatorChar s.0> : true,
		<IsSeparatorChar s.1> : true	=	"$separator" ('.') "$separator" <Scan e.e>;


	'[' e.all = "[" <Scan e.all>;
	']' e.all = "]" <Scan e.all>;
	'...' e.all = "..." <Scan e.all>;
	'..'  e.all = ".."  <Scan e.all>;
	'$NOT' e.all = "$not" <Scan e.all>;
	'$Not' e.all = "$not" <Scan e.all>;
	'$not' e.all = "$not" <Scan e.all>;
	'::=' e.all = (':')(':')('=') <Scan e.all>;
	'::' e.all = ('/') <Scan e.all>;
	' '  e.all = <Scan e.all>;
	'\n' e.all = <Scan e.all>;
	'\t' e.all = <Scan e.all>;
	'*' e.all = (Mul)	<Scan e.all>;
	'/' e.all = (Div)	<Scan e.all>;
	'+' e.all = (Add)	<Scan e.all>;
	'-' e.all = (Dec)	<Scan e.all>;
	'\''e.all = <Scan ('\'' ()) e.all>;
	'"' e.all = <Scan ('"'  ()) e.all>;
	(s.quo (e.e)) '\\' e.all,
		     e.all : {
				'\\' e.next =  <Scan (s.quo (e.e '\\')) e.next>;
				'n'  e.next =  <Scan (s.quo (e.e '\n')) e.next>;
				'\'' e.next =  <Scan (s.quo (e.e '\'')) e.next>;
				'"'  e.next =  <Scan (s.quo (e.e '"' )) e.next>;
				't'  e.next =  <Scan (s.quo (e.e '\t')) e.next>;

				s.s  e.next = <MakeError Scan 'unknown special symbol \\' s.s ' before "'e.next'"'>;
				e.e = <MakeError Scan 'unknown ARGUMENT: ' e.e>;
		};
	(s.quo (e.e)) s.quo e.all, s.quo : {
				'\'' =  e.e  <Scan e.all>;
				'"'  = (e.e) <Scan e.all>;
		};
	(s.quo (e.e)) s.sym e.all = <Scan (s.quo (e.e s.sym)) e.all>;

	e.all, <Type e.all> : {
			'L's.sub e.all, <Implode  e.all > : t.word e.else = (t.word) <Scan e.else>;
			'D's.sub e.all, 
				<ImplNumb e.all > : t.word s.separ e.else,
				<Type s.separ> : s.s e.e,
				'LD' : e.e1 s.s e.e2  =  <Scan 'drefVName'e.all>;  /* имя переменной с цифры */
				
			'D's.sub e.all, <ImplNumb e.all > : t.word e.else = (t.word) <Scan e.else>;
			'Pl' s.w e.1 = (s.w) <Scan e.1>;
			s.1 s.2 s.3 e.e = <MakeError Scan 'unknown type "'s.1 s.2 '" of RIGHT-PART elemet of ' e.all>;
			e.e = <MakeError Scan 'unknown ARGUMENT TYPE: ' e.e>;
		};
}

Same {
	t.1 t.1 = true;
	t.1 t.2 = false;
}



/*
FixVarLinksInSent{ e.e = <Prout '::::<FixVarLinksInSent 'e.e'>'><FixVarLinksInSent_ e.e>; }
FixVarLinksInSent_ {
	(e.vn) e.1 "<VAR>" e.vt '.' e.vn "</VAR>" e.2 = e.1 "<LNK>" e.vn "</LNK>" <FixVarLinksInSent (e.vn) e.2>;
	(e.vn) e.e = e.e;
}
*/

/* переводит закр. перем. в ссылки */
FixVarLinks{

	"<SENTENCE>" e.body "</SENTENCE>" e.2 = "<SENTENCE>" <FixVarLinks2 e.body> "</SENTENCE>" <FixVarLinks e.2>;
	t.template   e.body "</TEMPLATE>" e.2,	
		<Type    t.template> : 'W' s.subt t.template,
		<Explode t.template> : '<TEMPLATE' e.ee
			=	t.template <FixVarLinks2 e.body> "</TEMPLATE>" <FixVarLinks e.2>;
	t.1 e.e = t.1 <FixVarLinks e.e>;
	=;
	
}
/*
FixVarLinks{
	e.1 "<SENTENCE>" e.sent "</SENTENCE>" e.2 = <Print e.1> "<SENTENCE>" <FixVarLinks2 e.sent> "</SENTENCE>" <FixVarLinks e.2>;
	e.e=e.e;
}
*/
FixVarLinks2{
	e.1 "<VAR>" e.var "</VAR>" e.2 "<VAR>" e.var "</VAR>" e.3,
	    e.var : e.vtype '.' s.vname1 e.vname2
		    =   <FixVarLinks2 e.1 "<VAR>" e.var "</VAR>" e.2 "<LNK>" s.vname1 e.vname2 "</LNK>" e.3 >;

	e.e = e.e;
}




/*обрабатывает сообщения об ошибках, закрытые переменные переводит в ссылки на открытые*/
Preproc{
	e.all = <PrintErrors e.all><FormatXml <FixVarLinks <PreprocPragma e.all>>>;
}
/* расставляет отсутпы */
FormatXml {
	t.word e.e,
		<Type t.word>    : 'W' s.subt t.word,		
		<Explode t.word> : {
			'<TEMPLATE' e.somth = '\n\n\n' t.word <FormatXml e.e>;
			'<FUNCTION' e.somth = '\n\n\n' t.word <FormatXml e.e>;
			e.else = t.word <FormatXml e.e>;
		};
	
	t.1 e.e = t.1 <FormatXml e.e>;
	=;
}
PrintErrors {
	e.1 "@ERROR:" (e.msg) e.2 =
		<PProut "@ERROR:" e.msg>
		<PrintErrors e.2>;
	e.e = ;
}
/* метакодирует в xml, упрощает мета-код */
PreprocPragma{
	=;
	e.begin "</TEXT>" "<TEXT>" e.next = <PreprocPragma e.begin e.next>;
	"@ERROR:" (e.mes) e.next = "<ERROR>" <UnUgl e.mes> "</ERROR>" <PreprocPragma e.next>;
	'<' e.next = '&lt;'   <PreprocPragma e.next>;
	'>' e.next = '&gt;'   <PreprocPragma e.next>;
	'&' e.next = '&amp;'  <PreprocPragma e.next>;
	'\''e.next = '&apos;' <PreprocPragma e.next>;
	'"' e.next = '&quot;' <PreprocPragma e.next>;
	'\n'e.next = '&#xA;' <PreprocPragma e.next>;
	'-' e.next = '&#x2D;' <PreprocPragma e.next>;


	s.1 e.next = s.1 <PreprocPragma e.next>;
	e.e = <PProut "$$$$$$$$$ Preproc: " e.e>;
}
UnUgl {=;
	'<' = '\'&lt;\' ';
	'>' = '\'&gt;\' ';
	s.s = s.s;
	('<') e.next = '&lt;' <UnUgl e.next>;
	('>') e.next = '&gt;' <UnUgl e.next>;
	(e.e) e.next = e.e <UnUgl e.next>;
	"'" s.s e.next = <UnUgl s.s> <UnUgl e.next>;
	"'" t.t e.next = '\'' <UnUgl t.t e.next>;
	s.s e.e = '\'' <UnUgl s.s> <UnUgl e.e>;

}

PrintAll { e.e = <PProut e.e>; }


PProut { e.e = <Prout e.e>; }
PPrint { e.e = <Print e.e>; }


ScanTemplate {
	(e.tname)(':')(':')('=') e.left-part,
		<ScanLeftPart e.left-part>   : e.lpscaned,
		<ExistError  e.lpscaned> : {
			false	=  "<LEFT-PART>" e.lpscaned "</LEFT-PART>";
			true	=  <MakeError ScanTemplate 'error left-part difinition in Template : ' e.lpscaned>;
		};

	e.else = <MakeError  ScanTemplate 'error template definition: ' e.else >;
}


FindAndUseBlock {
	()(';') e.e = <FindAndUseBlock ()e.e>;

	()("Template")(e.name)e.tmpl (';') e.next,
		<ScanTemplate (e.name)e.tmpl> : e.stp,
		<ExistError e.stp> : false
			=
				"<TEMPLATE name=\""e.name"\">"  e.stp "</TEMPLATE>"
				<FindAndUseBlock  () e.next> ;

	()("Template")e.tmpl (';') e.next 
			= 
				<MakeError <ScanTemplate e.tmpl>>
				<FindAndUseBlock  () e.next> ;
		

				
	(e.some)('{') e.e = <Rp scanbl'='<+ 1 <Cp scanbl>>> <FindAndUseBlock  (e.some ('{')) e.e>;
	(e.some)('}') e.e, <Cp scanbl> : {
			1 =
				<Rp scanbl'='0>
				<ScanModule e.some ('}')> <FindAndUseBlock ()e.e>;
			t.else =
				<Rp scanbl'='<- <Cp scanbl> 1>>
				<FindAndUseBlock (e.some ('}')) e.e>;
			};
	(e.some)t.sym e.e = <FindAndUseBlock (e.some t.sym) e.e>;
	(e.some), <Cp scanbl> : {
			0	= <ScanModule e.some>;
			t.else	= <MakeError  FindAndUseBlock  'ERROR body item at the end: ' t.else>;
			};
}


GetRandomName {
	= <Replace  (' :') <Time><Symb <Step>>>;
}
Replace { 
	(e.A s.1 e.B) e.2 s.1 e.3 = <Replace (e.A s.1 e.B) e.2 e.3>;
	(e.A) e.e = e.e; 
}