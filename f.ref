
Template theword  ::=  (word e.value);
Template theint   ::=  (int  e.value);

Template varname ::= { theword. | theint. } ;


Template FUNCTION ::= 
	{"$"(word ENTRY)' '|}  
	(word t.name) {' '|} ("{" BLOCK.body) {' '|};

Template TEMPLATE ::=
	(word Template) ' ' theword.name {' '|} ":" ":" "=" LEFT_PART.body ;

PROGRAM {
	FUNCTION.f  {";" |} E.next = <Prout 'F: ' @.f::name> <PROGRAM @.next>;
	TEMPLATE.tm  ";" E.next = <Prout 'T: ' @.tm::name> <PROGRAM @.next>;
	' ' e.e = <PROGRAM e.e>;
	=;
	e.else = 'no: ' e.else;
}

	
Template BLOCK ::= SENTENCE.head ";" {' '|} { BLOCK. |}.tail ;
Template SENTENCE   ::=  { LEFT_PART. | }.left_part "=" { RIGHT_PART. | }.right_part ;

Template LEFT_PART  ::=  L_PATTERN.pattern { IFs. |}.conditions ;
Template RIGHT_PART ::=  R_PATTERN.pattern ;

Template IFs ::= "," IF.head {IFs.|}.tail;
Template IF  ::= RIGHT_PART.right_part ":" L_PATTERN.left_part;


Template L_PATTERN ::= { | L_PATTERN_nonemp. } ;
Template R_PATTERN ::= { | R_PATTERN_nonemp. } ;

Template L_PATTERN_nonemp ::=
	L_ITEM.head {L_PATTERN_nonemp. |}.tail ;
Template R_PATTERN_nonemp ::=
	R_ITEM.head {R_PATTERN_nonemp. |}.tail ;

Template L_ITEM ::=
	{ ' '| ("(" L_PATTERN. ) | VAR. | LNK. | SYMBOL. } ;

Template R_ITEM ::=
	{ ' '| ("(" RIGHT_PART. ) | ("<" R_PATTERN_nonemp. ) | VAR. | LNK. | SYMBOL. } ;

Template SYMBOL ::=
	{ theword. | (int e.) | (real e.) | (text e.) | "$" (word empty) } ;


Template VAR    ::= {
	theword.type1  	       SPECIFICATORS.s1  "." { varname. | }.name1 |
	GROUP_OR_VARIANT.type2  SPECIFICATORS.s2  { "." varname. | }.name2  
};
					

Template LNK    ::=  { {  "@"{theword.|} | "&"{theword.|} | theword. }.type "." varname.name }.thevar  VAR_PATH.path ;
Template VAR_PATH ::= { ":" ":" varname. VAR_PATH. | $empty } ;

Template GROUP_OR_VARIANT ::= ("{" e.) ; 

Template SPECIFICATORS ::= { { REPEATER. }.head SPECIFICATORS.tail |} ;
Template REPEATER ::= ("[" e.); 

SELECT_ALLVAR {
	( E.a ) E.b = <SELECT_ALLVAR @.a>     <SELECT_ALLVAR @.b>;
	VAR.v   E.b = &VAR.v 		      <SELECT_ALLVAR @.b>;
	s.1 E.b = <SELECT_ALLVAR @.b>;
	$empty = $empty;
};



	

Go {
	= <Prout <PROGRAM
		<Prout 'xx'>
		<DelComments <RefalTokens <Mount 'f.ref'>>>
		<Prout 'yy'>
	>>;
}

DelComments_ {
	e.e = <Prout 'del: 'e.e><DelComments_ e.e>;
}
DelComments {
	{' '|} (comment e.) {' '|} e.e = <DelComments e.d>;
	e.0 ( {"("|"{"|"["|"<"}.sig  e.1 ) e.e = e.0 (@.sig <DelComments e.1>) <DelComments e.e>;
	t.1 e.e = @.1 <DelComments e.e>;
	=;
}

PProut {
	(text e.e) e.next = "'" e.e "'" <PProut e.next>;
	( {int|word|real} e.e ) e.next = e.e <PProut e.next>;
	{' '|"."|"|"}.sym   e.next = @.sym <PProut e.next>;
	=;
	e.else = <Prout 'error: [' e.else ']'>;
}


F {
	 e.e = ; 
}
