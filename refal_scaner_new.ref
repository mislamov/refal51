// **********************************************
//	Препроцессор D-Refal программ.
// **********************************************
//   1.      prescaning-парсинг (чтение знаков языка)
//   2.      структуризация и синтаксический анализ (генерация структуры программы)
//   3.      семантический анализ и оптимизация (перестройка структуры программы)
//   4.      построение байт/xml-кода
InputFile{='refal_scaner_new.ref';}

$Entry Go { = <Prout <P1_Prescaning <Print <P1_Prescaning_pre 0 '\n'<Mount <InputFile>>'\n' >>>>; }


Template comment  ::= { '/*' e. '*/' | '//' e. '\n' } ! ;
Template Digit ::= { '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '0' };
Template Digits	  ::= Digit. { Digits. | } !;
Template Letter	  ::= { 'z'|'x'|'c'|'v'|'b'|'n'|'m'|'a'|'s'|'d'|'f'|'g'|'h'|'j'|'k'|'l'|'q'|'w'|'e'|'r'|'t'|'y'|'u'|'i'|'o'|'p'|
			'Z'|'X'|'C'|'V'|'B'|'N'|'M'|'A'|'S'|'D'|'F'|'G'|'H'|'J'|'K'|'L'|'Q'|'W'|'E'|'R'|'T'|'Y'|'U'|'I'|'O'|'P' 
			};


DoError { int.line e.text = <Prout '#### ERROR ['@.line']: ' @.text>; }

// счет строк для сообщений об ошбках
P1_Prescaning_pre {
	int.line  e.pred '\n' E.next,
		<+ 1 int.line> : int.newline 
		=	@.pred  '\n'<Implode '$line:' int.newline> <P1_Prescaning_pre int.newline @.next>;
	int.line  E.next =  E.next <Implode '$line:' <+ 1 @.line>>;
}
//   1.      prescaning-парсинг (чтение знаков языка)
P1_Prescaning {
	{ ' ' | '\t' | comment. }[infin] E.next  
					=  "$separator" <P1_Prescaning  @.next>;
	{'...'|'..'|'.'|'::='|'::'|':'|'='|'{'|'}'|'['|']'|'('|')'|'<'|'>'|'|'}.item  E.next 
					=  <Implode @.item> <P1_Prescaning  @.next>;
	Digits.num  E.next  
					=  <Numb @.num> <P1_Prescaning  @.next>; /// todo: вещественные в разных форматах
	{ Letter. e. }.word { s.notletter ! E.nn }.next,
		$NOT s.notletter : Letter. ,
		$NOT s.notletter : Digit.
					=  <Implode @.word>  <P1_Prescaning  @.next>;
	t.unknown e.text t.linelable E.next,
		<Explode  t.linelable>: '$line:' Digits.line
					=  <DoError <Numb @.line> 'Unexpected item `' t.unknown '` here : ' t.unknown e.text>;
}



//   2.      структуризация и синтаксический анализ (генерация структуры программы)
//   3.      семантический анализ и оптимизация (перестройка структуры программы)
//   4.      построение байт/xml-кода





































//Template comment  ::= { '/*' e. '*/' | '//' e. '\n'  | '\n*' e. '\n' } ! ;

/*
Template ResvWord ::= {'Template' | '$NOT' };
Template Alpha 	  ::= { 'z'|'x'|'c'|'v'|'b'|'n'|'m'|'a'|'s'|'d'|'f'|'g'|'h'|'j'|'k'|'l'|'q'|'w'|'e'|'r'|'t'|'y'|'u'|'i'|'o'|'p'|
			'Z'|'X'|'C'|'V'|'B'|'N'|'M'|'A'|'S'|'D'|'F'|'G'|'H'|'J'|'K'|'L'|'Q'|'W'|'E'|'R'|'T'|'Y'|'U'|'I'|'O'|'P' 
			};
Template Digit ::= { '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '0' };
Template Digits	  ::= Digit. { Digit. Digits. | } !;
Template Alphas	  ::= Alpha. { Alpha. | Digit. }[infin] ;

// в строке раскрывает все метасимволы с '\' 
UnEscape {
	'\\' { '\\' | 'n'='\n' | 't'='\t' | '"' | '\'' }.sym E.next  =  @.sym <UnEscape E.next>;
	'\\' s.sym  E.next   =  <MakeError 'unknown escaped code: \\'s.sym> <UnEscape E.next>;
	s.s  E.next 	     =  s.s <UnEscape  E.next>;
}


//	Подготовка к парсингу:
//	- создание меток строки для дебага и сообщений об ошибках
	
PreParse {
	int.line e.first '\n' E.next,  
		<+ 1 int.line> : int.newline 
		=	e.first  <Implode '$line:' int.newline> <PreParse int.newline E.next>;
	int.line E.next  
		=  	<Implode '$line:' <+ int.line 1>> E.next;		
	E.else	=	<PreParse 0 E.else>;
}

//	Парсинг-сканирование
Parse {
	{ ' ' | '\t' | comment. }[infin] E.next  =  ("$separator") <Parse E.next>;
	'\n' E.next = <SystemError 'Unexpected \\n symbol after PreParse. before this: ' E.next>;
	ResvWord.word  E.next	= <Implode <LowerCase @.word>> <Parse E.next>;
	Alphas.id  E.next  	= <Implode <LowerCase @.id>>   <Parse E.next>;
	Digits.id  E.next  	= <Numb    @.id> <Parse E.next>;
	{ '...' | '..' | '.'  |
	  '['   | ']'  | 
	  '{'   | '}'  | 
	  '::=' |
	  '::'  | '@'
	}.item  E.next  	= ( @.item ) <Parse E.next>;
	
	'\'' e.string '\'' E.next,
		$NOT e.string : E. '\\' =  <UnEscape e.string> <Parse E.next>;
	'"' e.string '"' E.next,
		$NOT e.string : E. '\\' =  <Implode  <UnEscape e.string>> <Parse E.next>;
	
	Alphas.word  E.next = (Alphas.word)  <Parse E.next>;
	Word.preParseed  E.next = Word.preParseed  <Parse E.next>;
	s.unkn E.next = <MakeError 'Error syntax here: ' s.unkn E.next>;
	=;
}

// ********* Синтаксис D-REFAL после <Parse> **********
// если все части варианта имеют переменную с общим именем, то ее значение доступно через '::' . Можно использовать Empty. - переменную в альтернативах

Template Separator ::= ("$separator");

Template Empty	::= ;
Template Obrazec		::=  ;  // образец
Template RefData		::=  ;  // данное рефала: число буква слово байт

Template Vint  ::=  { RefVariable. | int. }; // целое или переменная. Потом проверить, что переменная - закрытая int

// ПЕРЕМЕННАЯ
Template RefVariable  		::=  RefVariableDescriptor.type ('.') { (Alphas.) | }.name;
Template RefVariableDescriptor	::=  { Alphas. | ('{') Obrazec. ('}') | ('@') }.descriptor  RefRepeater.repeater
Template RefRepeater	::= {
			('[') Vint.from ('..' ) Vint.to (']')  		  |
			('[') Vint.from ('...') {Empty.=infin}.to   (']')     |
			('[') "infin" (']') {Empty.=infin}.from {Empty.=infin}.to |
			{Empty.=1}.from {Empty.=1}.to
}; // export: .from .to 





// может запретить данные-компаут-символы без кавычек? Без кавычек только элементы языка?
ParseObjectExprWithExecs {
	=;

	"$separator"	E.e = 		 <ParseObjectExprWithExecs E.e>;
	"$not"		E.e = 	"<NOT/>" <ParseObjectExprWithExecs E.e>;

	// отсечение 
	('!')  e.e = "<CUTTER/>" <ParseObjectExprWithExecs e.e>;

	// разделитель вариантов 
	('|')  e.e = "|" <ParseObjectExprWithExecs e.e>;

	// групповые скобки c именем 
	('{')  e.oexp  ('}')('.')(t.varname) e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false,
		<Type t.varname> : {
			'W' s.sub t.varname = "<GROUP_F name=\"" <Explode t.varname> "\">" e.oexp_I "</GROUP_F>" <ParseObjectExprWithExecs e.e>;
			'N' s.sub t.varname = "<GROUP_F name=\"" <Symb t.varname>    "\">" e.oexp_I "</GROUP_F>" <ParseObjectExprWithExecs e.e>;
			e.else = <MakeError ParseObjectExprWithExecs 'bad varname for GROUP-brackets'>;
		};

	// ВАРИАНТЫ 
	('{')  e.oexp  ('}')"["(e.from)".."(e.to)"]"('.')(t.varname) e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname "\">" 
		"<REPEAT from=\"" e.from "\" to=\"" e.to "\">" 
			"<GROUP_F name=\""  <GetRandomName> "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ParseObjectExprWithExecs e.e>;

	('{')  e.oexp  ('}')"["(e.from)"..." "]" ('.')(t.varname) e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname "\">" 
		"<REPEAT from=\"" e.from "\" to=\"inf\">" 
			"<GROUP_F name=\""  <GetRandomName> "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ParseObjectExprWithExecs e.e>;

	('{')  e.oexp  ('}')"[" "..."(e.to)"]" ('.')(t.varname) e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname "\">" 
		"<REPEAT from=\"0\" to=\""e.to"\">" 
			"<GROUP_F name=\"" <GetRandomName>  "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ParseObjectExprWithExecs e.e>;

	('{')  e.oexp  ('}')"[" (e.fromto)"]" ('.')(t.varname) e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname  "\">" 
		"<REPEAT from=\""e.fromto"\" to=\""e.fromto"\">" 
			"<GROUP_F name=\"" <GetRandomName>  "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ParseObjectExprWithExecs e.e>;



	// групповые скобки без имени 
	('{')  e.oexp  ('}') e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\""  <GetRandomName>  "\">" e.oexp_I "</GROUP_F>" <ParseObjectExprWithExecs e.e>;

		
	
	

	// Скобки 
	('(') e.inside (')') e.next,
	<ParseObjectExprWithExecs e.inside> : e.insideParseed_I,
	<ExistError  e.insideParseed_I> : false
	=	"<BRACKET>"  e.insideParseed_I "</BRACKET>" <ParseObjectExprWithExecs  e.next >;

	('<') (t.word) e.inside ('>') e.next,
	<ParseObjectExprWithExecs e.inside> : e.insideParseed_I,
	<ExistError  e.insideParseed_I> : false

	=	"<EXEC>" "<WORD>" t.word "</WORD>"  e.insideParseed_I "</EXEC>" <ParseObjectExprWithExecs e.next>;




	// продолжение ссылки напеременную 
	"$path" ('/')(t.1) e.next, 
		<Type t.1> : 'W' s.sub1 t.1
		=	'/' <Explode t.1> <ParseObjectExprWithExecs  "$path" e.next>;

	// конец ссылки напеременную 
	"$path" e.next		
		=	"</LNK>" <ParseObjectExprWithExecs  e.next>;



	// ссылка на переменную
	(t.1)('.')(t.2)('/') e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'W' s.sub2 t.2
	=	"<LNK>" <Explode t.2>
		<ParseObjectExprWithExecs "$path" ('/') e.next>;

	// ссылка на переменную c числовым именем
	(t.1)('.')(t.2)('/') e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'N' s.sub2 t.2
	=	"<LNK>" <Symb t.2>
		<ParseObjectExprWithExecs "$path" ('/') e.next>;

	// переменная
	(t.1)('.')(t.2) e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'W' s.sub2 t.2
	=	"<VAR>" <Explode t.1> '.' <Explode t.2> "</VAR>"
		<ParseObjectExprWithExecs e.next>;

	// переменная с числовым именем
	(t.1)('.')(t.2) e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'N' s.sub2 t.2
	=	"<VAR>" <Explode t.1> '.' <Symb t.2> "</VAR>"
		<ParseObjectExprWithExecs e.next>;
	

	// переменная без имени
	(t.1)('.') "$separator" e.next,
	<Type t.1> : 'W' s.sub1 t.1
	=	"<VAR>" <Explode t.1> '.' "</VAR>"
		<ParseObjectExprWithExecs e.next>;
	

	// ссылка на переменную с НЕ числовым именем
	('@')('.')(t.2) e.next,
	<Type t.2> : 'W' s.sub2 t.2
	=	"<LNK>" <Explode t.2> "</LNK>"
		<ParseObjectExprWithExecs e.next>;
	

	// ссылка на переменную с числовым именем
	('@')('.')(t.2) e.next,
	<Type t.2> : 'N' s.sub2 t.2
	=	"<LNK>" <Symb t.2> "</LNK>"
		<ParseObjectExprWithExecs e.next>;
	

	// просто слово или число
	(t.1) e.next, <Type t.1> :
				{
					'N' s.sub t.1 = "<INT>" <Symb t.1> "</INT>"   <ParseObjectExprWithExecs e.next>;
					'W' s.sub t.1 = "<WORD>" <Explode t.1> "</WORD>" <ParseObjectExprWithExecs e.next>;
					s.T s.sub t.1 = "@ERROR:" ('unkonown symbol in object-expression = "' t.1 '" of type [' s.T s.sub '] in ' (t.1) e.next);
				};


	// термальное предложение
	(e.1) e.next  =  "<WORD>" e.1 "</WORD>" <ParseObjectExprWithExecs e.next>;

	// не возможно появления тут аргумента вида (t.1) e.2   !!! 

	s.s e.next = "<TEXT>" s.s "</TEXT>" <ParseObjectExprWithExecs e.next>;

	e.error = <MakeError ParseObjectExprWithExecs e.error>;

}

// **********************************************************
// *
// * Разбор элементов языка
// *
// **********************************************************

ParseModule_ { e.e = <PProut "\nParseModule: " e.e><ParseModule_ e.e>; }
ParseModule {
	=;

	// подразумевается, что обрабатывается только один внешний блок 
	(t.fname) ('{') e.bodyPredl ('}'),
	<ParsePredlsInBody e.bodyPredl>   : e.bodyParseed,
	<ExistError e.bodyParseed> : {
		false	=	"<FUNCTION name=\"" t.fname "\">" e.bodyParseed "</FUNCTION>\n"  ;
		true 	= 	<MakeError ParseModule e.bodyParseed>;
		};


	('$') ( e.entry ) e.else,
		<Upper <Explode e.entry>> : 'ENTRY' = <ParseModule e.else>;

	e.error = <MakeError ParseModule e.error>;
}

ParsePredlsInBody_  { e.e = <PProut "\nParsePredlsInBody: " <DeScob e.e>><ParsePredlsInBody_ e.e>; }
ParsePredlsInBody {
	e.predl (';') e.nextBodyPredl,
	<ParsePredl e.predl>	: e.pParseed,
	<ExistError e.pParseed>	: false,
	e.nextBodyPredl : {
					=	"<SENTENCE>" e.pParseed "</SENTENCE>";
				e.e	=	"<SENTENCE>" e.pParseed "</SENTENCE>" <ParsePredlsInBody e.e>;
	};

	e.predl t.last, 
		t.last : {
			(';')   = "<SENTENCE>" <ParsePredl  e.predl> "</SENTENCE>";
			t.last  = "<SENTENCE>" <ParsePredl  e.predl t.last> "</SENTENCE>";
		};

	= <MakeError ParsePredlsInBody  'can\'t be empty body of block'>;
}



ParsePredl_ { e.e = <PProut "\nParsePredl: " <DeScob e.e>><ParsePredl_ e.e>; }
ParsePredl  {
	// блок - недоработанная заглушка. создает вызов не существуюущей функции 
	e.left-part (',') e.RIGHT-PART (':') ('{') e.block ('}'),

	<ParseRigthPart e.RIGHT-PART> : e.rpParseed,
	<ExistError e.rpParseed> : false,

	<ParseLeftPart e.left-part> : e.lpParseed,
	<ExistError e.lpParseed> : false,

	<ParsePredlsInBody e.block> : e.bParseed,
	<ExistError e.bParseed> : false,

	<GetRand> : t.rand,
	<Explode t.rand> : e.randtext,
	<ParseIfs (',') e.RIGHT-PART (':') (e)('.')(t.rand)> : e.lp

	=	"<LEFT-PART>"  e.lpParseed  e.lp  "</LEFT-PART>"
		"<RIGHT-PART>" <ParseRigthPart  ('<')(t.rand)(e)('.')(t.rand)('>')> "</RIGHT-PART>";


	e.leftpart ('=') e.rigthpart,
	<ParseLeftPart  e.leftpart>  : e.leftParsened,
	<ExistError e.leftParsened> : {
		true  = <MakeError ParsePredl e.leftParsened>;

		false,
		<ParseRigthPart e.rigthpart> : e.rigthParsened,
		<ExistError e.rigthParsened> : {
			false	=
				"<LEFT-PART>"  e.leftParsened  "</LEFT-PART>"
				"<RIGHT-PART>" e.rigthParsened "</RIGHT-PART>";
			true	=
				<MakeError ParsePredl e.rigthParsened>;
			};
	};

	e.error = <MakeError ParsePredl e.error>;

}
ParseLeftPart_ { e.e = <PProut "\nParseLeftPart: " <DeScob e.e>><ParseLeftPart_ e.e>; }
ParseLeftPart {
	=;

	e.shablon (',') e.ifs =
			<ParseObjectExprWithoutExecs e.shablon>
			<ParseIfs (',') e.ifs>;
	e.shablon = <ParseObjectExprWithoutExecs e.shablon>;
//	e.error = <MakeError ParseLeftPart e.error>;
}



ParseRigthPart_ { e.e = <PProut "\nParseRigthPart: " <DeScob e.e>><PProut "\nParseRigthPart: " e.e><ParseRigthPart_ e.e>; }
ParseRigthPart {
	e.rp = <ParseObjectExprWithExecs  e.rp>;
}



ParseObjectExprWithoutExecs_ { e.e = <PProut "\nParseObjectExprWithoutExecs: " e.e><ParseObjectExprWithoutExecs_ e.e>; }
ParseObjectExprWithoutExecs {
	e.arg, 
		<ParseObjectExprWithoutExecsFirst e.arg> : e.arg_I,
		<ExistError e.arg_I> : { 
			false	=	<TransformSpecificatorsInObjectExprWithoutExecs e.arg_I>;
			true	=	e.arg_I;
		};
}

IsVarName {
	e.name,
	<Type e.name> : {
		'L' s.sub s.1 e.2 = <IsVarName e.2>;
		'D' s.sub s.1 e.2 = <IsVarName e.2>;
		'*' e.e = true;
		e.else = false;
	};
}

// перестраивает спецификаторы для загрузки программы: 
//	варианты:	  {o   | => o   | => o   | => x   ? }
TransformSpecificatorsInObjectExprWithoutExecs_ { e.e = <Prout "TransformSpecificatorsInObjectExprWithoutExecs:" e.e><TransformSpecificatorsInObjectExprWithoutExecs e.e>; };
TransformSpecificatorsInObjectExprWithoutExecs {
	e.all,
	e.all : e.1 "<GROUP_F name=\"" e.gname "\">" e.2 "</GROUP_F>" e.3,
		<NotHas "</GROUP_F>" e.2> : true,
		<NotHas "<GROUP_F name=\"" e.2> : true,
		<IsVarName e.gname> : true,
		e.2 : e.4 "|" e.5  
		=  	<TransformSpecificatorsInObjectExprWithoutExecs   
				e.1 
				"<GROUP name=\"" 
				e.gname 
				"\">" 
				"<VARIANTS>" 
				<ReplaceAll ("|") by ("<THE-VARIANT/>") in (e.2)> 
				"</VARIANTS>" 
				"</GROUP>" 
				e.3 
			>;

	e.all,
	e.all : e.1 "<GROUP_F name=\"" e.gname "\">" e.2 "</GROUP_F>" e.3,
		<NotHas "</GROUP_F>" e.2> : true,
		<NotHas "<GROUP_F name=\"" e.2> : true
		=	<TransformSpecificatorsInObjectExprWithoutExecs   e.1 "<GROUP name=\"" e.gname "\">" e.2 "</GROUP>" e.3 >;

	e.noOldGroups = e.noOldGroups;
}

ParseObjectExprWithoutExecsFirst {
	e.1 ('<') e.2 = <MakeError ParseObjectExprWithoutExecs 'unecpected "<" in <' e.2>;
	e.1 ('>') e.2 = <MakeError ParseObjectExprWithoutExecs 'unecpected ">" in >' e.2>;
	e.e = <ParseObjectExprWithExecs e.e>; // уже знаем, что нету вызовов 
}

ReplaceAll {
	(e.old) by (e.new) in (e.arg),
		e.arg : e.1 e.old e.2 = e.1 e.new <ReplaceAll  (e.old) by (e.new) in (e.2)>;
		
	(e.old) by (e.new) in (e.arg) = e.arg;
}

NotHas {
	t.A e.1 t.A e.2 = false;
	e.e = true;
}

IsWordNumbDot {
	('.') = true;
	(t.word),
		<Type t.word> : {
				'Wi' t.word = true;
				'N0' t.word = true;
				e.e = false;
			};

	//"$separator" = false;
	t.else = false;
}

ParseObjectExprWithExecs_ { e.e = <PProut "\nParseObjectExprWithExecs: " e.e><ParseObjectExprWithExecs_ e.e>; }
ParseObjectExprWithExecs {
	=;

	"$separator"	e.e = 	<ParseObjectExprWithExecs e.e>;
	"$not"		e.e = 	"<NOT/>"  <ParseObjectExprWithExecs e.e>;
	
	// отсечение 
	('!')  e.e = "<CUTTER/>" <ParseObjectExprWithExecs e.e>;

	// разделитель вариантов 
	('|')  e.e = "|" <ParseObjectExprWithExecs e.e>;

	// групповые скобки c именем 
	('{')  e.oexp  ('}')('.')(t.varname) e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false,
		<Type t.varname> : {
			'W' s.sub t.varname = "<GROUP_F name=\"" <Explode t.varname> "\">" e.oexp_I "</GROUP_F>" <ParseObjectExprWithExecs e.e>;
			'N' s.sub t.varname = "<GROUP_F name=\"" <Symb t.varname>    "\">" e.oexp_I "</GROUP_F>" <ParseObjectExprWithExecs e.e>;
			e.else = <MakeError ParseObjectExprWithExecs 'bad varname for GROUP-brackets'>;
		};

	// ВАРИАНТЫ 
	('{')  e.oexp  ('}')"["(e.from)".."(e.to)"]"('.')(t.varname) e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname "\">" 
		"<REPEAT from=\"" e.from "\" to=\"" e.to "\">" 
			"<GROUP_F name=\""  <GetRandomName> "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ParseObjectExprWithExecs e.e>;

	('{')  e.oexp  ('}')"["(e.from)"..." "]" ('.')(t.varname) e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname "\">" 
		"<REPEAT from=\"" e.from "\" to=\"inf\">" 
			"<GROUP_F name=\""  <GetRandomName> "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ParseObjectExprWithExecs e.e>;

	('{')  e.oexp  ('}')"[" "..."(e.to)"]" ('.')(t.varname) e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname "\">" 
		"<REPEAT from=\"0\" to=\""e.to"\">" 
			"<GROUP_F name=\"" <GetRandomName>  "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ParseObjectExprWithExecs e.e>;

	('{')  e.oexp  ('}')"[" (e.fromto)"]" ('.')(t.varname) e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\"" t.varname  "\">" 
		"<REPEAT from=\""e.fromto"\" to=\""e.fromto"\">" 
			"<GROUP_F name=\"" <GetRandomName>  "\">"
			e.oexp_I 
			"</GROUP_F>"
		"</REPEAT>" 
		"</GROUP_F>" 
		<ParseObjectExprWithExecs e.e>;



	// групповые скобки без имени 
	('{')  e.oexp  ('}') e.e,
		<ParseObjectExprWithExecs e.oexp> : e.oexp_I,
		<ExistError  e.oexp_I> : false
	=	"<GROUP_F name=\""  <GetRandomName>  "\">" e.oexp_I "</GROUP_F>" <ParseObjectExprWithExecs e.e>;

		
	
	

	// Скобки 
	('(') e.inside (')') e.next,
	<ParseObjectExprWithExecs e.inside> : e.insideParseed_I,
	<ExistError  e.insideParseed_I> : false
	=	"<BRACKET>"  e.insideParseed_I "</BRACKET>" <ParseObjectExprWithExecs  e.next >;

	('<') (t.word) e.inside ('>') e.next,
	<ParseObjectExprWithExecs e.inside> : e.insideParseed_I,
	<ExistError  e.insideParseed_I> : false

	=	"<EXEC>" "<WORD>" t.word "</WORD>"  e.insideParseed_I "</EXEC>" <ParseObjectExprWithExecs e.next>;




	// продолжение ссылки напеременную 
	"$path" ('/')(t.1) e.next, 
		<Type t.1> : 'W' s.sub1 t.1
		=	'/' <Explode t.1> <ParseObjectExprWithExecs  "$path" e.next>;

	// конец ссылки напеременную 
	"$path" e.next		
		=	"</LNK>" <ParseObjectExprWithExecs  e.next>;



	// ссылка на переменную
	(t.1)('.')(t.2)('/') e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'W' s.sub2 t.2
	=	"<LNK>" <Explode t.2>
		<ParseObjectExprWithExecs "$path" ('/') e.next>;

	// ссылка на переменную c числовым именем
	(t.1)('.')(t.2)('/') e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'N' s.sub2 t.2
	=	"<LNK>" <Symb t.2>
		<ParseObjectExprWithExecs "$path" ('/') e.next>;

	// переменная
	(t.1)('.')(t.2) e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'W' s.sub2 t.2
	=	"<VAR>" <Explode t.1> '.' <Explode t.2> "</VAR>"
		<ParseObjectExprWithExecs e.next>;

	// переменная с числовым именем
	(t.1)('.')(t.2) e.next,
	<Type t.1> : 'W' s.sub1 t.1,
	<Type t.2> : 'N' s.sub2 t.2
	=	"<VAR>" <Explode t.1> '.' <Symb t.2> "</VAR>"
		<ParseObjectExprWithExecs e.next>;
	

	// переменная без имени
	(t.1)('.') "$separator" e.next,
	<Type t.1> : 'W' s.sub1 t.1
	=	"<VAR>" <Explode t.1> '.' "</VAR>"
		<ParseObjectExprWithExecs e.next>;
	

	// ссылка на переменную с НЕ числовым именем
	('@')('.')(t.2) e.next,
	<Type t.2> : 'W' s.sub2 t.2
	=	"<LNK>" <Explode t.2> "</LNK>"
		<ParseObjectExprWithExecs e.next>;
	

	// ссылка на переменную с числовым именем
	('@')('.')(t.2) e.next,
	<Type t.2> : 'N' s.sub2 t.2
	=	"<LNK>" <Symb t.2> "</LNK>"
		<ParseObjectExprWithExecs e.next>;
	

	// просто слово или число
	(t.1) e.next, <Type t.1> :
				{
					'N' s.sub t.1 = "<INT>" <Symb t.1> "</INT>"   <ParseObjectExprWithExecs e.next>;
					'W' s.sub t.1 = "<WORD>" <Explode t.1> "</WORD>" <ParseObjectExprWithExecs e.next>;
					s.T s.sub t.1 = "@ERROR:" ('unkonown symbol in object-expression = "' t.1 '" of type [' s.T s.sub '] in ' (t.1) e.next);
				};


	// термальное предложение
	(e.1) e.next  =  "<WORD>" e.1 "</WORD>" <ParseObjectExprWithExecs e.next>;

	// не возможно появления тут аргумента вида (t.1) e.2   !!! 

	s.s e.next = "<TEXT>" s.s "</TEXT>" <ParseObjectExprWithExecs e.next>;

	e.error = <MakeError ParseObjectExprWithExecs e.error>;

}


ParseIfs_ { e.e = <PProut "\nParseIfs: " e.e><PProut "\nParseIfs: " <DeScob e.e>><ParseIfs_ e.e>; }
ParseIfs {
	=;

	// несколько условий 
	
	(',') e.RIGHT-PART (':') e.next,
	<ParseRigthPart e.RIGHT-PART> : e.rpParseed,
	<ExistError  e.rpParseed> e.next : {
		false e.left-part (',') e.ifs,
		<ParseLeftPart e.left-part>   : e.lpParseed,
		<ExistError  e.lpParseed> : {
				false, e.rpParseed : "<NOT/>" e.rpParseednext
				= 	"<IF not=\"true\">" "<RIGHT-PART>" e.rpParseednext "</RIGHT-PART>" "<LEFT-PART>" e.lpParseed "</LEFT-PART>" "</IF>"
					<ParseIfs (',') e.ifs>;
					
				false, e.lpParseed : "<NOT/>" e.lpParseednext
				= 	"<IF not=\"true\">" "<RIGHT-PART>" e.rpParseed "</RIGHT-PART>" "<LEFT-PART>" e.lpParseednext "</LEFT-PART>" "</IF>"
					<ParseIfs (',') e.ifs>;
					
				false
				= 	"<IF>" "<RIGHT-PART>" e.rpParseed "</RIGHT-PART>" "<LEFT-PART>" e.lpParseed "</LEFT-PART>" "</IF>"
					<ParseIfs (',') e.ifs>;
					
				true  = <MakeError ParseIfs e.lpParseed>;
		};

		false e.left-part,
		<ParseLeftPart e.left-part>   : e.lpParseed,
		<ExistError  e.lpParseed> : {
				false, e.rpParseed : "<NOT/>" e.rpParseednext 
				= 	"<IF not=\"true\">" "<RIGHT-PART>" e.rpParseednext "</RIGHT-PART>" "<LEFT-PART>" e.lpParseed "</LEFT-PART>" "</IF>";
				false, e.lpParseed : "<NOT/>" e.lpParseednext 
				= 	"<IF not=\"true\">" "<RIGHT-PART>" e.rpParseed "</RIGHT-PART>" "<LEFT-PART>" e.lpParseednext "</LEFT-PART>" "</IF>";
				false
				= 	"<IF>" "<RIGHT-PART>" e.rpParseed "</RIGHT-PART>" "<LEFT-PART>" e.lpParseed "</LEFT-PART>" "</IF>";
				true  
				=	<MakeError ParseIfs e.lpParseed>;
		};

		true  e.next	=   <MakeError ParseIfs e.rpParseed>;
	};

	e.error = <MakeError ParseIfs e.error>;
}


************************
ExistError { e.1 "@ERROR:" (e.msg) e.2 = true; e.else = false; }
MakeError  {
	t.fname e.1 "@ERROR:" (e.msg) e.2 	= "@ERROR:" (e.msg);
	t.fname e.e 	= "@ERROR:" ('value unParseed by <'t.fname'> : 'e.e) ;
}
DeScob {
 (e.1) e.2 = e.1 <DeScob e.2>;
 s.1 e.e = s.1 <DeScob e.e>;
 =;
}






GetRand { ,<Rp rand'='<+ 1 <Cp rand>>>:e.e = <Implode 'rrrr98358935897389457'<Symb <Cp rand>>> ;  }


$ENTRY Go { =
		<Open 'w' 3 <Arg 1>'.xml'>
		<Br rand'='0>
		<Br Parsebl'='0>
			<Put 3 <DePlode "<BEGIN>"<Preproc <FindAndUseBlock() <Parse <Mount <Arg 1> >>>>"</BEGIN>">>;
}

// переводит все термы в текст 
DePlode {
	=;
	s.1 e.e, <Type s.1>:'W'e.ee = <Explode s.1> <DePlode e.e>;
	t.1 e.e = t.1 <DePlode e.e>;
}


$ENTRY Go1 {
	=	<Br rand'='0><PProut <GetRand>><PProut <GetRand>><PProut <GetRand>><PProut <GetRand>>;
}


IsSeparatorChar {
	' '  = true;
	'\t' = true;
	'\n' = true;
	s.s = false;
}



Parse{
	=;
	'/*'  e.comm '* / e.next  =  <Parse e.next>;
	'\n' '*' e.comm '\n' e.next  =  <Parse '\n' e.next>;


	s.1 '.' e.e,
		<IsSeparatorChar s.1> : true =	"$separator" ('.') <Parse e.e>;
	'.' s.1 e.e,
		<IsSeparatorChar s.1> : true =	('.') "$separator" <Parse e.e>;
	s.0 '.' s.1 e.e,
		<IsSeparatorChar s.0> : true,
		<IsSeparatorChar s.1> : true	=	"$separator" ('.') "$separator" <Parse e.e>;


	'[' e.all = "[" <Parse e.all>;
	']' e.all = "]" <Parse e.all>;
	'...' e.all = "..." <Parse e.all>;
	'..'  e.all = ".."  <Parse e.all>;
	'$NOT' e.all = "$not" <Parse e.all>;
	'$Not' e.all = "$not" <Parse e.all>;
	'$not' e.all = "$not" <Parse e.all>;
	'::=' e.all = (':')(':')('=') <Parse e.all>;
	'::' e.all = ('/') <Parse e.all>;
	' '  e.all = <Parse e.all>;
	'\n' e.all = <Parse e.all>;
	'\t' e.all = <Parse e.all>;
	'*' e.all = (Mul)	<Parse e.all>;
	'/' e.all = (Div)	<Parse e.all>;
	'+' e.all = (Add)	<Parse e.all>;
	'-' e.all = (Dec)	<Parse e.all>;
	'\''e.all = <Parse ('\'' ()) e.all>;
	'"' e.all = <Parse ('"'  ()) e.all>;
	(s.quo (e.e)) '\\' e.all,
		     e.all : {
				'\\' e.next =  <Parse (s.quo (e.e '\\')) e.next>;
				'n'  e.next =  <Parse (s.quo (e.e '\n')) e.next>;
				'\'' e.next =  <Parse (s.quo (e.e '\'')) e.next>;
				'"'  e.next =  <Parse (s.quo (e.e '"' )) e.next>;
				't'  e.next =  <Parse (s.quo (e.e '\t')) e.next>;

				s.s  e.next = <MakeError Parse 'unknown special symbol \\' s.s ' before "'e.next'"'>;
				e.e = <MakeError Parse 'unknown ARGUMENT: ' e.e>;
		};
	(s.quo (e.e)) s.quo e.all, s.quo : {
				'\'' =  e.e  <Parse e.all>;
				'"'  = (e.e) <Parse e.all>;
		};
	(s.quo (e.e)) s.sym e.all = <Parse (s.quo (e.e s.sym)) e.all>;

	e.all, <Type e.all> : {
			'L's.sub e.all, <Implode  e.all > : t.word e.else = (t.word) <Parse e.else>;
			'D's.sub e.all, 
				<ImplNumb e.all > : t.word s.separ e.else,
				<Type s.separ> : s.s e.e,
				'LD' : e.e1 s.s e.e2  =  <Parse 'drefVName'e.all>;  // имя переменной с цифры 
				
			'D's.sub e.all, <ImplNumb e.all > : t.word e.else = (t.word) <Parse e.else>;
			'Pl' s.w e.1 = (s.w) <Parse e.1>;
			s.1 s.2 s.3 e.e = <MakeError Parse 'unknown type "'s.1 s.2 '" of RIGHT-PART elemet of ' e.all>;
			e.e = <MakeError Parse 'unknown ARGUMENT TYPE: ' e.e>;
		};
}

Same {
	t.1 t.1 = true;
	t.1 t.2 = false;
}




// переводит закр. перем. в ссылки 
FixVarLinks{

	"<SENTENCE>" e.body "</SENTENCE>" e.2 = "<SENTENCE>" <FixVarLinks2 e.body> "</SENTENCE>" <FixVarLinks e.2>;
	t.template   e.body "</TEMPLATE>" e.2,	
		<Type    t.template> : 'W' s.subt t.template,
		<Explode t.template> : '<TEMPLATE' e.ee
			=	t.template <FixVarLinks2 e.body> "</TEMPLATE>" <FixVarLinks e.2>;
	t.1 e.e = t.1 <FixVarLinks e.e>;
	=;
	
}

FixVarLinks2{
	e.1 "<VAR>" e.var "</VAR>" e.2 "<VAR>" e.var "</VAR>" e.3,
	    e.var : e.vtype '.' s.vname1 e.vname2
		    =   <FixVarLinks2 e.1 "<VAR>" e.var "</VAR>" e.2 "<LNK>" s.vname1 e.vname2 "</LNK>" e.3 >;

	e.e = e.e;
}




// обрабатывает сообщения об ошибках, закрытые переменные переводит в ссылки на открытые
Preproc{
	e.all = <PrintErrors e.all><FormatXml <FixVarLinks <PreprocPragma e.all>>>;
}
// расставляет отсутпы 
FormatXml {
	t.word e.e,
		<Type t.word>    : 'W' s.subt t.word,		
		<Explode t.word> : {
			'<TEMPLATE' e.somth = '\n\n\n' t.word <FormatXml e.e>;
			'<FUNCTION' e.somth = '\n\n\n' t.word <FormatXml e.e>;
			e.else = t.word <FormatXml e.e>;
		};
	
	t.1 e.e = t.1 <FormatXml e.e>;
	=;
}
PrintErrors {
	e.1 "@ERROR:" (e.msg) e.2 =
		<PProut "@ERROR:" e.msg>
		<PrintErrors e.2>;
	e.e = ;
}
// метакодирует в xml, упрощает мета-код 
PreprocPragma{
	=;
	e.begin "</TEXT>" "<TEXT>" e.next = <PreprocPragma e.begin e.next>;
	"@ERROR:" (e.mes) e.next = "<ERROR>" <UnUgl e.mes> "</ERROR>" <PreprocPragma e.next>;
	'<' e.next = '&lt;'   <PreprocPragma e.next>;
	'>' e.next = '&gt;'   <PreprocPragma e.next>;
	'&' e.next = '&amp;'  <PreprocPragma e.next>;
	'\''e.next = '&apos;' <PreprocPragma e.next>;
	'"' e.next = '&quot;' <PreprocPragma e.next>;
	'\n'e.next = '&#xA;' <PreprocPragma e.next>;
	'-' e.next = '&#x2D;' <PreprocPragma e.next>;


	s.1 e.next = s.1 <PreprocPragma e.next>;
	e.e = <PProut "$$$$$$$$$ Preproc: " e.e>;
}
UnUgl {=;
	'<' = '\'&lt;\' ';
	'>' = '\'&gt;\' ';
	s.s = s.s;
	('<') e.next = '&lt;' <UnUgl e.next>;
	('>') e.next = '&gt;' <UnUgl e.next>;
	(e.e) e.next = e.e <UnUgl e.next>;
	"'" s.s e.next = <UnUgl s.s> <UnUgl e.next>;
	"'" t.t e.next = '\'' <UnUgl t.t e.next>;
	s.s e.e = '\'' <UnUgl s.s> <UnUgl e.e>;

}

PrintAll { e.e = <PProut e.e>; }


PProut { e.e = <Putout 8 e.e><Prout e.e>; }
PPrint { e.e = <Putout 8 e.e><Print e.e>; }


ParseTemplate {
	(e.tname)(':')(':')('=') e.left-part,
		<ParseLeftPart e.left-part>   : e.lpParseed,
		<ExistError  e.lpParseed> : {
			false	=  "<LEFT-PART>" e.lpParseed "</LEFT-PART>";
			true	=  <MakeError ParseTemplate 'error left-part difinition in Template : ' e.lpParseed>;
		};

	e.else = <MakeError  ParseTemplate 'error template definition: ' e.else >;
}


FindAndUseBlock {
	()(';') e.e = <FindAndUseBlock ()e.e>;

	()("Template")(e.name)e.tmpl (';') e.next,
		<ParseTemplate (e.name)e.tmpl> : e.stp,
		<ExistError e.stp> : false
			=
				"<TEMPLATE name=\""e.name"\">"  e.stp "</TEMPLATE>"
				<FindAndUseBlock  () e.next> ;

	()("Template")e.tmpl (';') e.next 
			= 
				<MakeError <ParseTemplate e.tmpl>>
				<FindAndUseBlock  () e.next> ;
		

				
	(e.some)('{') e.e = <Rp Parsebl'='<+ 1 <Cp Parsebl>>> <FindAndUseBlock  (e.some ('{')) e.e>;
	(e.some)('}') e.e, <Cp Parsebl> : {
			1 =
				<Rp Parsebl'='0>
				<ParseModule e.some ('}')> <FindAndUseBlock ()e.e>;
			t.else =
				<Rp Parsebl'='<- <Cp Parsebl> 1>>
				<FindAndUseBlock (e.some ('}')) e.e>;
			};
	(e.some)t.sym e.e = <FindAndUseBlock (e.some t.sym) e.e>;
	(e.some), <Cp Parsebl> : {
			0	= <ParseModule e.some>;
			t.else	= <MakeError  FindAndUseBlock  'ERROR body item at the end: ' t.else>;
			};
}


GetRandomName {
	= <Replace  (' :') <Time><Symb <Step>>>;
}
Replace { 
	(e.A s.1 e.B) e.2 s.1 e.3 = <Replace (e.A s.1 e.B) e.2 e.3>;
	(e.A) e.e = e.e; 
}
*/
