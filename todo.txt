переменная - произвольный указатель:  &.pointvar
определеиться с семантикой: 
	указатель на простое ов (как адресат: &usertype::foo::oexpr)
	указатель на ргуппу/вариант с одной переменной:    { Atype.a | Btype.b }.vv  =>  &.vv == Xtype 

пуллы самых тяжелых объектов
в подстановке - подставлять только ссылки (без копирования)
сканирующие скобки
апостраф bash
извлечение списка (когда не из указателя хотим получить указатели):  
	PATTERN.pattern, 
		<SELECT FROM (PATTERN.pattern) (type is VAR)> : { &VAR. }[1...]




+) каркас к модулю: функции, предложения
+) скобки-вызовов функций <>
+) простой пример
+) загрузчик xml, правильная загрузка всего, втч скобок
+) ссылки на переменные (закрытые переменные)  
+) вычисление функции, построение подстановки
+) простой вычислитель поля зрения
+) еще пару тестов без условий
+) шаблон-условие, условие в matching
+) проверить цепочку условий с откатами
+) пользовательский шаблон
+) ссылка на часть польз-кого шаблона
+) шаблонные конструкции - группы, порстые повторители(без TVarBody)
+) простые типы данных и переменные
+)  	s. t. e. E.
+)	int. real. byte. letter. word.
+)	целые числа, термальные слова, буквы (не юникод)
	
~) модульность
+) модуль system - перенести основное в него: 

	Sub,Dec  -
	Div  	 /
	Mul  	 *
	Add,Sum  +
	
	Lenw - длина выражения
	Compare - сравнение
	
	Mount - загрузить содержимое файла
	Card  - чтение с консоли
	Prout - вывод
	Print - вывод

+) вычислитель поля зрения
+) ПРЕ-альфа

-) поддержка указателей на ОВ:  &UserType.varname
 ) переписать препроцессор на D-Refale
 ) альфа
 ) юникод
 ) оптимизировать подстановку

 ) отрицание: диапазон действия $not{  ..  }
 ) объекты (ссылки на объектные выр-я)
 ) методы пользовательских шаблонов! (гибчайшая замена рефал-блокам)
 ) отсекающее условие - отсечение действющее не на образец, а на всю левую часть.
 
 ) сложные повторители (один TVarBody на всю цепочку [] )
 ) списки объектов из []
 
 ) функция LoadProgram - доопределение текущей программы
 ) сканирующие скобки
 ) массивы байтов 
 ) перестроить загрузку модулей - раскрыть позднее связывание (замена нулл-заглушек в стеке заглушек),
  в предложениях заменить связку переменных и ссылок по имени на связку по адресу ссылки
 ) монтирующая функция массивов байтов
+) сборка мусора или основу сделать на ссылках
 ) блоки свободных самооптимизирующихся предложений в функциях
 ) бесконечные числа
 ) активные варианты:   e. { 'x' = 'икс' | 'y' | 'z' = 'зет' }.what e.  :::  <F 'оxygen'> -> 'oиксygen'
-----------------
баги:
 ) последние e и E переменные при неудачных if-условиях продолжают сопоставляться (затем ]) - надо делать сразу откат
 ) открытые переменные внутри варианта видны вне варианта! исправиь в новом парсере
 ) если в условии правая часть вызывает пользовательскую функцию неуспешно...
 ) отрицательные целые в исходнике (минус впереди)...
 ) мусорные точки в test2_template.ref

ЗАМЕТКИ И ИДЕИ:


e.1   e.2    e.3  { VarType.name }[3..6].arr e.4  =  @VarType[].arr 

$Template  Array = { 'var: ' Word.name }[3..8].items;

e. Array.A e.  =  @.A  -  ссылка на переменную
e. Array.A e.  =  &A  -  создание термального объекта
e. Array.A e.  =  Array.A::items::name


ЗАПРЕТИТЬ ШАБЛОНАМ НАЧИНАТЬСЯ И ЗАКАНЧИВАТЬСЯ НА е ИЛИ Е ПЕРЕМЕННЫЕ !!!
либо убирать оптимизатором, либо что-то еще

Использовать Е переменные внутри шаблонов нужно осторожно - их жадность распространяется не только внутри описания шаблона, но и на все "вызывающие" левые части - вплоть до левой части предложения вычисляемой функции
Возможно запретить


Cutter можно сделать скобочным - откат закрытого форсируется до открытого. часть кода будет как в structBracket. сами structbracket можно будет окружать cutter-ами и сделать их примитивными:   ![  (  ...  ) !]

проверить нескобочный cutter (!) в конце определения образца пользовательского шаблона.


цепочку для очистки мусора делать внутри треда!


ОПТИМИЗАЦИЯ =====-----
(e.x1 e.End), <CompletionTable>: e.L((e.End)e.Qst)e.R = e.x1 e.Qst ;   -   многокрантные вызовы функции CompletionTable не нужны, так как результат всегда один (суперкомпиляция)
e.var )  -> END.var )

Для шаблонов (точнее переменных - их несравнимо меньше чем данных) можно хранить частые функции как ссылки на методы прямо в объекте - больше памяти но меньше скорость!!!
Например next_template()

Сборщик мусора: чем моложе объект, тем его время жизни скорее всего будет меньше. => в сборщике мусора удалять объекты с конца и не ообязательно все.


БИБЛИОТЕКА СТАНДАРТНЫХ АЛГОРИТМОВ
Наибольшая общая подстрока (longest common substring)  - LCsStr
Наибольшая общая подпоследовательность (англ. longest common subsequence) LCsSeq



e.  Array.A e.  =  <F 'fff' &Array.A 'fff'>;      //  создание ссылки
e. &Array.A e.  =  <F 'fff' &Array.A 'fff'>;      //  передача указателя на Array.A
e. &Array.A e.  =  <F 'fff'  Array.A      'fff'>; //  передача Array.A
e.  Array.A e.  =  <F 'fff' &Array.A::foo 'fff'>; //  передача указателя на Array.A::foo
e. &Array.A e.  =  <F 'fff' &Array.A::foo 'fff'>; //  --\\--
e. &Array.A e.  =  <F 'fff'  Array.A::foo 'fff'>; //  передача Array.A::foo


e.   Array.A  &Array.A e.  =  ....      //  создание ссылки
e.  &Array.A   Array.A e.  =  ....      //  создание ссылки
e.  &Array.A  &Array.A e.  =  ....      //  создание ссылки

