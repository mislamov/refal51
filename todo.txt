+) каркас к модулю: функции, предложения
+) скобки-вызовов функций <>
+) простой пример
+) загрузчик xml, правильная загрузка всего, втч скобок
+) ссылки на переменные (закрытые переменные)  
+) вычисление функции, построение подстановки
+) простой вычислитель поля зрения
+) еще пару тестов без условий
+) шаблон-условие, условие в matching
+) проверить цепочку условий с откатами
+) пользовательский шаблон
+) ссылка на часть польз-кого шаблона
+) шаблонные конструкции - группы, порстые повторители(без TVarBody)
+) простые типы данных и переменные
+)  	s. t. e. E.
-)	int. real. byte. letter. word.
+)	целые числа, термальные слова, буквы (не юникод)
	
~) модульность
+) модуль system - перенести основное в него: 

	Sub,Dec  -
	Div  	 /
	Mul  	 *
	Add,Sum  +
	
	Lenw - длина выражения
	Compare - сравнение
	
	Mount - загрузить содержимое файла
	Card  - чтение с консоли
	Prout - вывод
	Print - вывод

+) вычислитель поля зрения
) ПРЕ-альфа
) альфа

) переписать препроцессор на D-Refale
) юникод
) оптимизировать подстановку

) отрицание: диапазон действия $not{  ..  }
) объекты (ссылки на объектные выр-я)
) методы пользовательских шаблонов! (гибчайшая замена рефал-блокам)
) отсекающее условие - отсечение действющее не на образец, а на всю левую часть.

) сложные повторители (один TVarBody на всю цепочку [] )
) списки объектов из []

) функция LoadProgram - доопределение текущей программы
) сканирующие скобки
) массивы байтов 
) перестроить загрузку модулей - раскрыть позднее связывание (замена нулл-заглушек в стеке заглушек),
  в предложениях заменить связку переменных и ссылок по имени на связку по адресу ссылки
) монтирующая функция массивов байтов
+) сборка мусора или основу сделать на ссылках
) блоки свободных самооптимизирующихся предложений в функциях
) бесконечные числа
) активные варианты:   e. { 'x' = 'икс' | 'y' | 'z' = 'зет' }.what e.  :::  <F 'оxygen'> -> 'oиксygen'
-----------------
баги:
) последние e и E переменные при неудачных if-условиях продолжают сопоставляться (затем ]) - надо делать сразу откат
) открытые переменные внутри варианта видны вне варианта! исправиь в новом парсере
) если в условии правая часть вызывает пользовательскую функцию неуспешно...
) отрицательные целые в исходнике (минус впереди)...
) мусорные точки в test2_template.ref

ЗАМЕТКИ И ИДЕИ:


e.1   e.2    e.3  { VarType.name }[3..6].arr e.4  =  @VarType[].arr 

$Template  Array = { 'var: ' Word.name }[3..8].items;

e. Array.A e.  =  @.A  -  ссылка на переменную
e. Array.A e.  =  &A  -  создание термального объекта
e. Array.A e.  =  Array.A::items::name


ЗАПРЕТИТЬ ШАБЛОНАМ НАЧИНАТЬСЯ И ЗАКАНЧИВАТЬСЯ НА е ИЛИ Е ПЕРЕМЕННЫЕ !!!
либо убирать оптимизатором, либо что-то еще

Использовать Е переменные внутри шаблонов нужно осторожно - их жадность распространяется не только внутри описания шаблона, но и на все "вызывающие" левые части - вплоть до левой части предложения вычисляемой функции
Возможно запретить


Cutter можно сделать скобочным - откат закрытого форсируется до открытого. часть кода будет как в structBracket. сами structbracket можно будет окружать cutter-ами и сделать их примитивными:   ![  (  ...  ) !]

проверить нескобочный cutter (!) в конце определения образца пользовательского шаблона.


цепочку для очистки мусора делать внутри треда!


ОПТИМИЗАЦИЯ =====-----
(e.x1 e.End), <CompletionTable>: e.L((e.End)e.Qst)e.R = e.x1 e.Qst ;   -   многокрантные вызовы функции CompletionTable не нужны, так как результат всегда один (суперкомпиляция)
e.var )  -> END.var )

Для шаблонов (точнее переменных - их несравнимо меньше чем данных) можно хранить частые функции как ссылки на методы прямо в объекте - больше памяти но меньше скорость!!!
Например next_template()



БИБЛИОТЕКА СТАНДАРТНЫХ АЛГОРИТМОВ
Наибольшая общая подстрока (longest common substring)  - LCsStr
Наибольшая общая подпоследовательность (англ. longest common subsequence) LCsSeq

